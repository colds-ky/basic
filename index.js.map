{
  "version": 3,
  "sources": ["src/api/indexing/pull-plc-directory.js", "src/api/akpa.js", "src/api/retry-fetch.js", "lib/shorten.js", "lib/plc-directory.js", "src/index.js"],
  "sourcesContent": ["// @ts-check\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { plcDirectoryCompact } from '../../../lib/plc-directory';\nimport { parseTimestampOffset, timestampOffsetToString } from '../../../lib/shorten';\nimport { retryFetch } from '../retry-fetch';\n\nconst alertIfRecent = new Date(2023, 11, 1);\n\nexport async function pullPLCDirectoryCompact() {\n  console.log('PLC directory CACHE');\n\n  const directoryPath = path.resolve(__dirname, 'src/api/indexing/repos/directory');\n  console.log('Reading new directory files now...');\n  const wholeDirectory = readAllDirectoryFiles(directoryPath);\n  let maxDate = 0;\n  let maxContext;\n  for (const [shortDID, history] of Object.entries(wholeDirectory)) {\n    for (const entry of history) {\n      if (entry.timestamp > maxDate) {\n        if (entry.timestamp > alertIfRecent.getTime()) {\n          console.log(shortDID, history);\n          throw new Error('Incorrect timestamp! ' + new Date(entry.timestamp));\n        }\n\n        maxDate = entry.timestamp;\n        maxContext = { [shortDID]: history };\n      }\n    }\n  }\n\n  console.log('last: ', new Date(maxDate), ' ', maxContext);\n\n  console.log('Saving in new format...');\n  await saveAllDirectoryFiles(directoryPath, wholeDirectory);\n\n  let lastSave = Date.now();\n\n  console.log('Pulling PLC directory: ', new Date(maxDate), '...');\n  let lastChunkEntry;\n  for await (const chunk of plcDirectoryCompact(maxDate - 1000, { fetch: (req, opts) => retryFetch(req, { ...opts, nocorsproxy: true }) })) {\n    if (!chunk.entries.length) {\n      console.log('No new entries, last ', lastChunkEntry || new Date(maxDate));\n      continue;\n    }\n\n    lastChunkEntry = chunk.entries[chunk.entries.length - 1];\n\n    console.log(\n      chunk.entries.length,\n      { ...chunk.entries[0], timestamp: new Date(chunk.entries[0].timestamp).toISOString() },\n      '...',\n      {...chunk.entries[chunk.entries.length - 1], timestamp: new Date(chunk.entries[chunk.entries.length - 1].timestamp).toISOString() });\n\n    for (const entry of chunk.entries) {\n      const historyEntry = {\n        timestamp: entry.timestamp,\n        shortHandle:\n          !entry.shortHandle ? undefined :\n            entry.shortHandle.length > 20 ? entry.shortHandle.slice(0, 15) + '..' + entry.shortHandle.slice(-3) :\n              entry.shortHandle,\n        shortPDC: entry.shortPDC\n      };\n\n      const dirEntry = wholeDirectory[entry.shortDID];\n      if (!dirEntry) wholeDirectory[entry.shortDID] = [historyEntry];\n      else dirEntry.push(historyEntry);\n    }\n\n    if (Date.now() > lastSave + 40000) {\n      console.log('saving new format...');\n      await saveAllDirectoryFiles(directoryPath, wholeDirectory);\n      console.log('OK.\\n\\n');\n      lastSave = Date.now();\n    }\n  }\n}\n\n/**\n * @param {string} directoryPath\n * @param {{\n *  [shortDID: string]: HistoryEntry[];\n * }} wholeDirectory \n */\nasync function saveAllDirectoryFiles(directoryPath, wholeDirectory) {\n  const shortDIDsRaw = Object.keys(wholeDirectory);\n  const shortDIDsOrdered = shortDIDsRaw.slice().sort((did1, did2) => wholeDirectory[did1][0].timestamp - wholeDirectory[did2][0].timestamp);\n\n  let bucket = [];\n  for (const shortDID of shortDIDsOrdered) {\n    if (bucket.length >= 50000) {\n      saveBucket(shortDID);\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n    bucket.push(shortDID);\n  }\n\n  saveBucket();\n\n  function saveBucket(nextShortDID) {\n    const localPath = getTimestampFilePath(wholeDirectory[bucket[0]][0].timestamp);\n    const filePath = path.resolve(directoryPath, localPath);\n    process.stdout.write(' ' + localPath);\n    const saveJSON = stringifyDIDs(bucket, wholeDirectory, nextShortDID);\n    if (!fs.existsSync(path.dirname(filePath))) fs.mkdirSync(path.dirname(filePath), { recursive: true });\n\n    process.stdout.write('.');\n    const curTxt = !fs.existsSync(filePath) ? undefined :  fs.readFileSync(filePath, 'utf-8');\n    if (curTxt !== saveJSON) {\n      process.stdout.write('.');\n      fs.writeFileSync(filePath, saveJSON);\n    }\n    process.stdout.write('.');\n    bucket = [];\n  }\n}\n\n/**\n * @param {string[]} shortDIDs\n * @param {{\n *  [shortDID: string]: HistoryEntry[];\n * }} wholeDirectory\n * @param {string} [nextShortDID]\n */\nfunction stringifyDIDs(shortDIDs, wholeDirectory, nextShortDID) {\n  let saveJSON = '{\\n';\n\n  let carryTimestamp;\n  let commaBeforeNextEntry = false;\n\n  for (const shortDID of shortDIDs) {\n    if (commaBeforeNextEntry) saveJSON += ',\\n';\n    else commaBeforeNextEntry = true;\n\n    saveJSON += JSON.stringify(shortDID) + ':{';\n\n    const history = wholeDirectory[shortDID];\n\n    let timestamp = carryTimestamp;\n    let firstHistoryEntry= true;\n    for (let iEntry = 0; iEntry < history.length; iEntry++) {\n      const entry = history[iEntry];\n      const prevEntry = !iEntry ? undefined : history[iEntry - 1];\n      if (prevEntry?.shortHandle === entry.shortHandle && prevEntry?.shortPDC === entry.shortPDC) continue;\n\n      if (firstHistoryEntry) {\n        firstHistoryEntry = false;\n        carryTimestamp = entry.timestamp;\n      }\n      else {\n        saveJSON += ',';\n      }\n\n      const timestampStr =\n        timestamp ? timestampOffsetToString(entry.timestamp - timestamp) : new Date(entry.timestamp).toISOString();\n      timestamp = entry.timestamp;\n\n      saveJSON += JSON.stringify(timestampStr) + ':' + JSON.stringify({\n        h: entry.shortHandle === prevEntry?.shortHandle ? undefined : entry.shortHandle,\n        p: entry.shortPDC === prevEntry?.shortPDC ? undefined : entry.shortPDC\n      });\n    }\n\n    saveJSON += '}';\n  }\n\n  if (nextShortDID) {\n    const nextHistory = wholeDirectory[nextShortDID];\n    const nextFilePath = getTimestampFilePath(nextHistory[0].timestamp);\n    saveJSON += ',\\n' + JSON.stringify('next') + ':' + JSON.stringify('..' + nextFilePath);\n  }\n  saveJSON += '\\n}\\n';\n\n  return saveJSON;\n}\n\nfunction getTimestampFilePath(timestamp) {\n  const dt = new Date(timestamp);\n  const path =\n    dt.getUTCFullYear() + '/' +\n    (dt.getUTCMonth() + 1) + '-' +\n    dt.getUTCDate() + '-' +\n    dt.getUTCHours() +\n    (100 + dt.getMinutes()).toString().slice(1) +\n    (100 + dt.getSeconds()).toString().slice(1) + '.json';\n  return path;\n}\n\n/**\n * @param {string} directoryPath\n * @param {{\n *  [shortDID: string]: HistoryEntry[];\n * }} wholeDirectory \n */\nfunction saveAllDirectoryFilesOld(directoryPath, wholeDirectory) {\n  /** @type {{ [yearMonth: string]: { [shortDID: string]: HistoryEntry[] } }} */\n  const byMonth = {};\n  for (const [did, history] of Object.entries(wholeDirectory)) {\n    const dt = new Date(history[0].timestamp);\n    const yearMonth = dt.getUTCFullYear() + '/' + (dt.getUTCMonth() + 1);\n\n    const monthMap = byMonth[yearMonth] || (byMonth[yearMonth] = {});\n    monthMap[did] = history;\n  }\n\n  for (const [yearMonth, monthMap] of Object.entries(byMonth)) {\n    const directoryJSON = path.join(directoryPath, yearMonth + '.json');\n    if (!fs.existsSync(path.dirname(directoryJSON)))\n      fs.mkdirSync(path.dirname(directoryJSON), { recursive: true });\n\n    let saveJSON = '{\\n';\n\n    let carryTimestamp = Date.UTC(parseInt(yearMonth.split('/')[0]), parseInt(yearMonth.split('/')[1]) - 1, 1, 0, 0, 0, 0);\n    let firstShortDID = true;\n\n    const orderDIDs = Object.keys(monthMap).sort((shortDID1, shortDID2) => monthMap[shortDID1][0].timestamp - monthMap[shortDID2][0].timestamp);\n    for (const shortDID of orderDIDs) {\n      if (firstShortDID) firstShortDID = false;\n      else saveJSON += ',\\n';\n\n      saveJSON += JSON.stringify(shortDID) + ':{';\n\n      const history = monthMap[shortDID];\n\n      let timestamp = carryTimestamp;\n      let first = true;\n      for (const entry of history) {\n        if (first) {\n          first = false;\n          carryTimestamp = entry.timestamp;\n        }\n        else {\n          saveJSON += ',';\n        }\n\n        const dtOffset = timestampOffsetToString(entry.timestamp - timestamp);\n        timestamp = entry.timestamp;\n\n        saveJSON += JSON.stringify(dtOffset) + ':' + JSON.stringify({\n          h: !entry.shortHandle ? undefined : entry.shortHandle.length > 20 ? entry.shortHandle.slice(0, 15) + '..' + entry.shortHandle.slice(-3) : entry.shortHandle,\n          p: entry.shortPDC\n        });\n      }\n      saveJSON += '}';\n    }\n\n    saveJSON += '\\n}\\n';\n\n    fs.writeFileSync(directoryJSON, saveJSON);\n  }\n}\n\n/**\n * @typedef {{\n *  timestamp: number,\n *  shortHandle?: string,\n *  shortPDC?: string\n * }} HistoryEntry\n */\n\n\n/**\n * @typedef {{\n *  h?: string,\n *  p?: string\n * }} CompactHistoryEntry\n */\n\nfunction readAllDirectoryFiles(directoryPath) {\n\n  // it's always single file in 2022\n  /** @type {string | undefined} */\n  let localPath = path.relative(\n    directoryPath,\n    fs.readdirSync(path.join(directoryPath, '2022')).map(f => path.resolve(directoryPath, '2022', f)).filter(f => f.endsWith('.json'))[0]);\n\n  /** @type { {[shortDID: string]: HistoryEntry[] }} */\n  const wholeDirectory = {};\n  let filesCount = 0;\n  let chCount = 0;\n\n  while (localPath) {\n    const directoryJSON = path.join(directoryPath, localPath.replace(/^\\.\\.\\/?/, ''));\n\n    if (!fs.existsSync(directoryJSON)) break;\n    process.stdout.write(' ' + localPath);\n    localPath = undefined;\n    // { did: { dtOffset: { h: 'handle', p: 'pdc' }, dtOffset1: {h:'handle', p: 'pdc'} }  }\n    const txt = fs.readFileSync(directoryJSON, 'utf-8');\n    chCount += txt.length;\n    process.stdout.write('..');\n    const directoryObj = JSON.parse(txt);\n    process.stdout.write('.');\n    let carryTimestamp = 0;\n\n    for (const [did, history] of Object.entries(directoryObj)) {\n      if (did === 'next') {\n        localPath = history;\n        if (localPath?.startsWith('..') && !localPath.startsWith('../')) localPath = '../' + localPath.slice(2);\n        continue;\n      }\n\n      const historyList = wholeDirectory[did] = [];\n\n      let firstHistoryEntry = true;\n      let timestamp = carryTimestamp;\n      for (const [dateStr, compact] of Object.entries(history)) {\n\n        if (!carryTimestamp) {\n          timestamp = carryTimestamp = new Date(dateStr).getTime();\n          firstHistoryEntry = false;\n        } else if (firstHistoryEntry) {\n          firstHistoryEntry = false;\n          carryTimestamp += parseTimestampOffset(dateStr);\n          timestamp = carryTimestamp;\n        } else {\n          timestamp += parseTimestampOffset(dateStr);\n        }\n\n        if (timestamp > alertIfRecent.getTime()) {\n          console.log(did, history);\n          throw new Error('Incorrect timestamp! ' + new Date(timestamp));\n        }\n\n        historyList.push({\n          timestamp,\n          shortHandle: compact.h,\n          shortPDC: compact.p\n        });\n      }\n    }\n\n    filesCount++;\n  }\n\n  console.log(' ' + filesCount + ' files ' + chCount + ' characters');\n\n  return wholeDirectory;\n}\n\nfunction readAllDirectoryFilesOld(directoryPath) {\n  let year = 2022;\n  let month = 11;\n\n  const untilYear = new Date().getUTCFullYear(), untilMonth = new Date().getUTCMonth() + 1;\n\n  /** @type { {[shortDID: string]: HistoryEntry[] }} */\n  const wholeDirectory = {};\n  let filesCount = 0;\n  let chCount = 0;\n\n  while (year < untilYear || (year === untilYear && month <= untilMonth)) {\n    const localPath = year.toString() + '-/' + month.toString() + '.json';\n    const directoryJSON = path.join(directoryPath, localPath);\n\n    if (fs.existsSync(directoryJSON)) {\n      process.stdout.write(' ' + localPath);\n      // { did: { dtOffset: { h: 'handle', p: 'pdc' }, dtOffset1: {h:'handle', p: 'pdc'} }  }\n      const txt = fs.readFileSync(directoryJSON, 'utf-8');\n      chCount += txt.length;\n      process.stdout.write('..');\n      const directoryObj = JSON.parse(txt);\n      process.stdout.write('.');\n      let carryTimestamp = Date.UTC(year, month - 1, 1, 0, 0, 0, 0);\n\n      for (const [did, history] of Object.entries(directoryObj)) {\n        if (!wholeDirectory[did]) wholeDirectory[did] = [];\n\n        let first = true;\n        let timestamp = carryTimestamp;\n        for (const [dtOffsetStr, compact] of Object.entries(history)) {\n          const dtOffset = parseTimestampOffset(dtOffsetStr);\n          if (first) {\n            carryTimestamp += dtOffset;\n            first = false;\n          }\n          timestamp += dtOffset;\n\n          if (timestamp > alertIfRecent.getTime()) {\n            console.log(did, history);\n            throw new Error('Incorrect timestamp! ' + new Date(timestamp));\n          }\n\n          wholeDirectory[did].push({\n            timestamp,\n            shortHandle: !compact.h ? undefined : compact.h.length > 20 ? compact.h.slice(0, 15) + '..' + compact.h.slice(-3) : compact.h,\n            shortPDC: compact.p\n          });\n        }\n      }\n\n      filesCount++;\n    }\n\n    month++;\n    if (month > 12) {\n      year++;\n      month = 1;\n    }\n  }\n\n  console.log(' ' + filesCount + ' files ' + chCount + ' characters');\n\n  return wholeDirectory;\n}\n\n", "// @ts-check\n\n/**\n * @template [T=any]\n * @template [TBuffer = T[]]\n * @typedef {{\n *  yield: (item: T, combine?: (buffer: TBuffer | undefined, item?: T) => TBuffer) => Promise<void>,\n *  reject: (error: Error) => void,\n *  complete: () => void,\n *  isEnded: boolean,\n *  finally: Promise<void>\n * }} StreamParameters\n */\n\n/**\n * @template [T=any]\n * @template [TBuffer = T[]]\n * @param {(args: StreamParameters<T, TBuffer>) => void } callback\n * @returns {AsyncGenerator<TBuffer, void, unknown>}\n */\nexport async function* streamBuffer(callback) {\n\n  let finallyTrigger = () => { };\n  let stop = false;\n\n  /** @type {TBuffer | undefined} */\n  let buffer;\n\n  let continueTrigger = () => { };\n  /** @type {Promise<void>} */\n  let continuePromise = new Promise(resolve => continueTrigger = resolve);\n\n  let yieldPassedTrigger = () => { };\n  /** @type {Promise<void>} */\n  let yieldPassedPromise = new Promise(resolve => yieldPassedTrigger = resolve);\n\n  /** @type {{ error: Error } | undefined} */\n  let rejectError;\n\n  /** @type {Parameters<typeof callback>[0]} */\n  const args = {\n    yield: yieldFn,\n    reject,\n    complete,\n    isEnded: false,\n    finally: new Promise(resolve => finallyTrigger = resolve)\n  };\n\n  callback(args);\n\n  try {\n    while (!stop) {\n\n      await continuePromise;\n      if (rejectError)\n        throw rejectError.error;\n      if (stop) return;\n\n      continuePromise = new Promise(resolve => continueTrigger = resolve);\n      const yieldBuffer = buffer;\n      buffer = undefined;\n\n      if (yieldBuffer) {\n        yield yieldBuffer;\n\n        const yieldCompleted = yieldPassedTrigger;\n        yieldPassedPromise = new Promise(resolve => yieldPassedTrigger = resolve);\n\n        yieldCompleted();\n      }\n    }\n\n  } finally {\n    finallyTrigger();\n  }\n\n  /**\n   * @param {T} item\n   * @param {(buffer: TBuffer | undefined, item: T) => TBuffer} [combine]\n   */\n  function yieldFn(item, combine) {\n    if (stop) {\n      console.error('Cannot yield after complete.');\n      return /** @type Promise<void> */(new Promise(resolve => resolve()));\n    }\n    if (rejectError) {\n      console.error('Cannot yield after reject.');\n      return /** @type Promise<void> */(new Promise(resolve => resolve()));\n    }\n\n    if (typeof combine === 'function') {\n      buffer = combine(buffer, item);\n    } else {\n      if (!buffer) buffer = /** @type {TBuffer} */([]);\n      /** @type {*} */(buffer).push(item);\n    }\n\n    continueTrigger();\n\n    return yieldPassedPromise;\n  }\n\n  /** @param {Error} error */\n  function reject(error) {\n    if (stop) {\n      console.error('Cannot reject after complete.');\n      return;\n    }\n    if (rejectError) {\n      console.error('Cannot reject after reject.');\n      return;\n    }\n\n    rejectError = { error };\n    args.isEnded = true;\n  }\n\n  function complete() {\n    stop = true;\n    args.isEnded = true;\n    continueTrigger();\n  }\n}\n\n/**\n * @template T\n * @template [TProject = T]\n * @param {AsyncIterable<T>} input\n * @param {(item: T) => TProject} [project]\n */\nexport async function* map(input, project) {\n  for await (const item of input) {\n    const mapped = project ? project(item) : item;\n    yield mapped;\n  }\n}\n\n/**\n * @template T\n * @template [TProject=T extends Array ? T[0] : T]\n * @param {AsyncIterable<T>} input\n * @param {(item: T) => Iterable<TProject> | AsyncIterable<TProject>} [project]\n * @returns {AsyncIterable<TProject>}\n * }}\n */\nexport async function* mergeMap(input, project) {\n  for await (const item of input) {\n    const mapped = project ? project(item) : item;\n    for await (const subItem of /** @type {AsyncIterable<TProject>} */(mapped)) {\n      yield subItem;\n    }\n  }\n}\n\n/**\n * @template T\n * @param {(arg: {\n *  yield: (item: T) => Promise<void>,\n *  reject: (error: Error) => void,\n *  complete: () => void,\n *  finally: Promise<void>\n * }) => void } callback\n */\nexport function streamEvery(callback) {\n  return mergeMap(streamBuffer(callback));\n}\n", "// @ts-check\n\n/**\n * @typedef {{\n *  error: Error,\n *  started: number,\n *  tryCount: number,\n *  waitUntil: number\n * }} RetryArgs\n */\n\n/**\n * @param {Parameters<typeof fetch>[0] & { onretry?: ({}: RetryArgs) => void, nocorsproxy?: boolean }} req\n * @param {Parameters<typeof fetch>[1] & { onretry?: ({}: RetryArgs) => void, nocorsproxy?: boolean }} [init]\n * @returns {ReturnType<typeof fetch>}\n */\nexport async function retryFetch(req, init, ...rest) {\n  // only allow GET requests to use corsproxy\n  let corsproxyMightBeNeeded = (init?.method || '').toUpperCase() === 'get';\n  if (req.nocorsproxy || init?.nocorsproxy) corsproxyMightBeNeeded = false;\n\n  const started = Date.now();\n  let tryCount = 0;\n  while (true) {\n\n    try {\n      const useCors = tryCount && corsproxyMightBeNeeded && Math.random() > 0.5;\n      const re = useCors ? await fetchWithCors(req, init) : await fetch(req, init, ...rest);\n\n      if (re.status >= 200 && re.status < 400 ||\n        re.status === 404) {\n        // success or 404 is a sign of request having been processed\n        if (!useCors) corsproxyMightBeNeeded = false;\n        return re;\n      }\n\n      retry(new Error('HTTP' + re.status + ' ' + re.statusText));\n    } catch (e) {\n      await retry(e);\n    }\n  }\n\n  /** @param {Error} error */\n  function retry(error) {\n    tryCount++;\n    let onretry = req.onretry || init?.onretry;\n\n    const now = Date.now();\n    let waitFor = Math.min(\n      30000,\n      Math.max(300, (now - started) / 3)\n    ) * (0.7 + Math.random() * 0.6);\n\n    if (typeof onretry === 'function') {\n      const args = { error, started, tryCount, waitUntil: now + waitFor };\n      onretry(args);\n\n      // allow adjusting the timeout from onretry callback\n      if (args.waitUntil >= now)\n        waitFor = args.waitUntil - now;\n    }\n\n    console.warn(\n      tryCount + ' error' + (tryCount > 1 ? 's' : '') +\n      ', retry in ', waitFor, 'ms ',\n      req,\n      error);\n\n    return new Promise(resolve => setTimeout(resolve, waitFor));\n  }\n}\n\n/**\n * @param {Parameters<typeof fetch>[0]} req\n * @param {Parameters<typeof fetch>[1]} [init]\n * @returns {ReturnType<typeof fetch>}\n */\nfunction fetchWithCors(req, init, ...rest) {\n  if (typeof req === 'string') {\n    req = wrapCorsProxy(req);\n  } else if (req instanceof Request) {\n    req = new Request(wrapCorsProxy(req.url), req);\n  } else if (req instanceof URL) {\n    req = new URL(wrapCorsProxy(req.href));\n  } else {\n    req = {\n      .../** @type {*} */(req),\n      url: wrapCorsProxy(/** @type {*} */(req).url)\n    };\n  }\n\n  return /** @type {*} */(fetch)(req, init, ...rest);\n}\n\n/** @param {string} url */\nfunction wrapCorsProxy(url) {\n  const dt = Date.now();\n  const wrappedURL =\n    'https://corsproxy.com/?' + url +\n    (url.indexOf('?') < 0 ? '?' : '&') + 't' + dt + '=' + (dt + 1);\n  return wrappedURL;\n}", "// @ts-check\n\n/** @param {string | null | undefined} text */\nexport function likelyDID(text) {\n  return text && (\n    !text.trim().indexOf('did:') ||\n    text.trim().length === 24 && !/[^\\sa-z0-9]/i.test(text)\n  );\n}\n\n/**\n * @param {T} did\n * @returns {T}\n * @template {string | undefined | null} T\n */\nexport function shortenDID(did) {\n  return did && /** @type {T} */(did.replace(_shortenDID_Regex, '').toLowerCase() || undefined);\n}\n\nconst _shortenDID_Regex = /^did\\:plc\\:/;\n\nexport function unwrapShortDID(shortDID) {\n  return !shortDID ? undefined : shortDID.indexOf(':') < 0 ? 'did:plc:' + shortDID.toLowerCase() : shortDID.toLowerCase();\n}\n\n/**\n * @param {T} handle\n * @returns {T}\n * @template {string | undefined | null} T\n */\nexport function shortenHandle(handle) {\n  handle = cheapNormalizeHandle(handle);\n  return handle && /** @type {T} */(handle.replace(_shortenHandle_Regex, '').toLowerCase() || undefined);\n}\nconst _shortenHandle_Regex = /\\.bsky\\.social$/;\n\nexport function unwrapShortHandle(shortHandle) {\n  shortHandle = cheapNormalizeHandle(shortHandle);\n  return !shortHandle ? undefined : shortHandle.indexOf('.') < 0 ? shortHandle.toLowerCase() + '.bsky.social' : shortHandle.toLowerCase();\n}\n\nfunction cheapNormalizeHandle(handle) {\n  handle = handle && handle.trim().toLowerCase();\n\n  if (handle && handle.charCodeAt(0) === 64)\n    handle = handle.slice(1);\n\n  const urlprefix = 'https://bsky.app/';\n  if (handle && handle.lastIndexOf(urlprefix, 0) === 0) {\n    const postURL = breakPostURL(handle);\n    if (postURL && postURL.shortDID)\n      return postURL.shortDID;\n  }\n\n  if (handle && handle.lastIndexOf('at:', 0) === 0) {\n    const feedUri = breakFeedUri(handle);\n    if (feedUri && feedUri.shortDID)\n      return feedUri.shortDID;\n\n    if (handle && handle.lastIndexOf('at://', 0) === 0) handle = handle.slice(5);\n    else handle = handle.slice(3);\n  }\n\n  return handle || undefined;\n}\n\n/** @param {string | undefined | null} pdc */\nexport function shortenPDC(pdc) {\n  if (!pdc) return undefined;\n\n  pdc = pdc.trim().toLowerCase();\n\n  if (pdc === 'https://bsky.social') return '.s';\n  else if (pdc === 'https://bsky.network') return '.n';\n  else if (pdc === 'https://bsky.app') return '.a';\n\n  // https://morel.us-east.host.bsky.network\n  return pdc.replace(/^https:\\/\\//, '').replace(/host\\.bsky\\.network$/, '');\n}\n\nexport function unwrapShortPDC(shortPDC) {\n  if (!shortPDC) return undefined;\n\n  if (shortPDC === '.s') return 'https://bsky.social';\n  else if (shortPDC === '.n') return 'https://bsky.network';\n  else if (shortPDC === '.a') return 'https://bsky.app';\n\n  return 'https://' + shortPDC + 'host.bsky.network';\n}\n\n/** dd+hh:mm:ss */\nexport function parseTimestampOffset(dtOffsetStr) {\n  // 30+23:59:59\n\n  let offset = 0;\n  let lead = 0;\n  const plusPos = dtOffsetStr.indexOf('+');\n  if (plusPos >= 0) {\n    offset = Number(dtOffsetStr.substring(0, plusPos)) * 24 * 60 * 60 * 1000;\n    lead = plusPos + 1;\n  }\n\n  const secondsColonPos = dtOffsetStr.lastIndexOf(':');\n  if (secondsColonPos < 0) {\n    offset += Number(dtOffsetStr.substring(lead)) * 1000;\n  } else {\n    offset += Number(dtOffsetStr.substring(secondsColonPos + 1)) * 1000;\n\n    const minutesColonPos = dtOffsetStr.lastIndexOf(':', secondsColonPos - 1);\n    if (minutesColonPos < 0) {\n      offset += Number(dtOffsetStr.substring(lead, secondsColonPos)) * 60 * 1000;\n    } else {\n      offset += Number(dtOffsetStr.substring(minutesColonPos + 1, secondsColonPos)) * 60 * 1000;\n      offset += Number(dtOffsetStr.substring(lead, minutesColonPos)) * 60 * 60 * 1000;\n    }\n  }\n\n  return offset;\n}\n\n/** dd+hh:mm:ss */\nexport function timestampOffsetToString(offset) {\n  offset = Math.floor(offset / 1000);\n  const seconds = offset % 60;\n  offset = (offset - seconds) / 60;\n  const minutes = offset % 60;\n  offset = (offset - minutes) / 60;\n  const hours = offset % 24;\n  const days = (offset - hours) / 24;\n\n  let str = (100 + seconds).toString().slice(1);\n  if (days + hours + minutes) {\n    str = (100 + minutes).toString().slice(1) + ':' + str;\n    if (days + hours) {\n      str = hours.toString() + ':' + str;\n      if (days) {\n        str = days + '+' + str;\n      }\n    }\n  }\n\n  // no need for leading zero\n  if (str.lastIndexOf('0', 0) === 0) str = str.slice(1);\n\n  return str;\n}\n\n/**\n* @param {string | null | undefined} url\n*/\nexport function breakPostURL(url) {\n  if (!url) return;\n  const match = _breakPostURL_Regex.exec(url);\n  if (!match) return;\n  return { shortDID: match[1], postID: match[2] };\n}\nconst _breakPostURL_Regex = /^http[s]?\\:\\/\\/bsky\\.app\\/profile\\/([a-z0-9\\.\\:]+)\\/post\\/([a-z0-9]+)$/;\n\n/**\n* @param {string | null | undefined} uri\n*/\nexport function breakFeedUri(uri) {\n  if (!uri) return;\n  const match = _breakFeedUri_Regex.exec(uri);\n  if (!match || !match[3]) return;\n  return { shortDID: match[2], postID: match[3] };\n}\nconst _breakFeedUri_Regex = /^at\\:\\/\\/(did:plc:)?([a-z0-9]+)\\/[a-z\\.]+\\/?(.*)?$/;\n", "// @ts-check\n\nimport { streamBuffer } from '../src/api/akpa';\nimport { retryFetch } from '../src/api/retry-fetch';\nimport { shortenDID, shortenHandle, shortenPDC } from './shorten';\n\n/**\n * @typedef {{\n *  fetch?: typeof retryFetch\n * }} Overrides\n */\n\n/**\n * @typedef {{\n *  did: string,\n *  cid: string,\n *  nullified: boolean,\n *  createdAt: string,\n *  operation: {\n *    type: 'create' | 'plc_operation',\n *    sig: string,\n *    alsoKnownAs?: string[],\n *    handle?: string,\n *    prev: string | null,\n *    service?: string,\n *    services?: {\n *      atproto_pds?: {\n *        type: 'AtprotoPersonalDataServer',\n *        endpoint: string\n *      }\n *    },\n *    rotationKeys: any[],\n *    verificationMethods: {}\n *  }\n * }} PLCDirectoryEntry\n */\n\nconst FETCH_AHEAD_MSEC_MAX = 10000;\nconst FETCH_AHEAD_COUNT_MAX = 10000\n\n/**\n * @param {string | Date | number | null} [since]\n * @param {Overrides} [overrides]\n * @returns {AsyncGenerator<{ entries: PLCDirectoryEntry[], overlap: number }>}\n */\nexport function plcDirectory(since, overrides) {\n  const useFetch = overrides?.fetch || fetch;\n  return streamBuffer(async stream => {\n    const EXPORT_URL = 'https://plc.directory/export';\n\n    let sinceTime;\n    if (since) {\n      if (typeof since === 'string') {\n        since = new Date(since);\n      } else if (typeof since === 'number') {\n        since = new Date(since);\n      }\n\n      if (Number.isFinite(since.getTime()))\n        sinceTime = since.toISOString();\n    }\n\n    const lastChunkLines = new Set();\n    let lastWaitedForConsumptionAt = Date.now();\n    let collectedEntriesSinceLastWaitedForConsumption = 0;\n\n    while (true) {\n      const nextChunkRe = await useFetch(\n        EXPORT_URL + (sinceTime ? '?after=' + sinceTime : '')\n      );\n\n      if (stream.isEnded) return;\n\n      const nextChunkText = await nextChunkRe.text();\n\n      const chunkLines = nextChunkText.split('\\n');\n      let overlap = 0;\n      const nextChunkEnitres = [];\n      for (const line of chunkLines) {\n        if (lastChunkLines.has(line)) {\n          overlap++;\n          continue;\n        }\n\n        if (!line) continue;\n        nextChunkEnitres.push(JSON.parse(line));\n      }\n\n      if (nextChunkEnitres.length) {\n        lastChunkLines.clear();\n        for (const line of chunkLines) {\n          lastChunkLines.add(line);\n        }\n\n        collectedEntriesSinceLastWaitedForConsumption += nextChunkEnitres.length;\n      }\n\n      const waitForConsumption = stream.yield(\n        { entries: nextChunkEnitres, overlap },\n        (buffer, item) => {\n          if (!buffer) return item;\n          buffer.entries = buffer.entries.concat(item.entries);\n          buffer.overlap += item.overlap;\n          return buffer;\n        }\n      );\n      if (stream.isEnded) return;\n\n      const shouldWaitForConsumption =\n        collectedEntriesSinceLastWaitedForConsumption > FETCH_AHEAD_COUNT_MAX ||\n        Date.now() - lastWaitedForConsumptionAt > FETCH_AHEAD_MSEC_MAX ||\n        !nextChunkEnitres.length;\n      \n      if (shouldWaitForConsumption) {\n        await waitForConsumption;\n        if (stream.isEnded) return;\n      }\n\n      /** @type {Date | undefined} */\n      let nextSinceTime;\n      // iterate backwards to find timestamp just before latest\n      for (let i = 0; i < nextChunkEnitres.length; i++) {\n        const entry = nextChunkEnitres[nextChunkEnitres.length - i - 1];\n        if (entry.createdAt) {\n          const timestamp = new Date(entry.createdAt);\n          if (!nextSinceTime && timestamp.getTime()) {\n            nextSinceTime = timestamp;\n          } else if (nextSinceTime && timestamp.getTime() &&\n            timestamp.getTime() < nextSinceTime.getTime()) {\n            sinceTime = timestamp.toISOString();\n            break;\n          }\n        }\n      }\n    }\n\n  });\n}\n\n/**\n * @typedef {{\n *  timestamp: number,\n *  shortDID: string,\n *  shortHandle?: string,\n *  shortPDC?: string;\n * }} PLCDirectoryEntryCompact\n */\n\n/**\n * @param {string | Date | number | null} [since]\n * @param {Overrides} [overrides]\n * @returns {AsyncGenerator<{ entries: PLCDirectoryEntryCompact[] }>}\n */\nexport async function* plcDirectoryCompact(since, overrides) {\n  const iteration = plcDirectory(since, overrides);\n  for await (const chunk of iteration) {\n    const compactEntries = [];\n    for (const entry of chunk.entries) {\n      const timestamp = new Date(entry.createdAt).getTime();\n      const compact = {\n        timestamp,\n        shortDID: shortenDID(entry.did),\n        shortHandle: shortenHandle(\n          entry.operation.alsoKnownAs?.[0] || entry.operation.handle),\n        shortPDC: shortenPDC(\n          entry.operation.services?.atproto_pds?.endpoint ||\n          entry.operation.service)\n      };\n      compactEntries.push(compact);\n    }\n\n    yield { entries: compactEntries };\n  }\n}", "// @ts-check\n\nimport { pullPLCDirectoryCompact } from './api/indexing/pull-plc-directory';\n\n\nimport { plcDirectory, plcDirectoryCompact } from '../lib/plc-directory';\n\nexport async function pullPLCDirectoryLocal() {\n  console.log('Pulling PLC directory...');\n\n  // TODO: load existing directory from disk\n\n  for await (const chunk of plcDirectoryCompact()) {\n    console.log(chunk.entries.length, chunk.entries[0], '...', chunk.entries[chunk.entries.length - 1]);\n    break;\n  }\n}\n\nif (typeof require === 'function' && typeof process !== 'undefined' && typeof process.exit === 'function') {\n  pullPLCDirectoryCompact();\n} else {\n  pullPLCDirectoryLocal();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,kBAAe;AACf,oBAAiB;;;ACiBjB,WAAuB,aAAa,UAAU;AAAA;AAE5C,UAAI,iBAAiB,MAAM;AAAA,MAAE;AAC7B,UAAI,OAAO;AAGX,UAAI;AAEJ,UAAI,kBAAkB,MAAM;AAAA,MAAE;AAE9B,UAAI,kBAAkB,IAAI,QAAQ,aAAW,kBAAkB,OAAO;AAEtE,UAAI,qBAAqB,MAAM;AAAA,MAAE;AAEjC,UAAI,qBAAqB,IAAI,QAAQ,aAAW,qBAAqB,OAAO;AAG5E,UAAI;AAGJ,YAAM,OAAO;AAAA,QACX,OAAO;AAAA,QACP;AAAA,QACA;AAAA,QACA,SAAS;AAAA,QACT,SAAS,IAAI,QAAQ,aAAW,iBAAiB,OAAO;AAAA,MAC1D;AAEA,eAAS,IAAI;AAEb,UAAI;AACF,eAAO,CAAC,MAAM;AAEZ,4BAAM;AACN,cAAI;AACF,kBAAM,YAAY;AACpB,cAAI;AAAM;AAEV,4BAAkB,IAAI,QAAQ,aAAW,kBAAkB,OAAO;AAClE,gBAAM,cAAc;AACpB,mBAAS;AAET,cAAI,aAAa;AACf,kBAAM;AAEN,kBAAM,iBAAiB;AACvB,iCAAqB,IAAI,QAAQ,aAAW,qBAAqB,OAAO;AAExE,2BAAe;AAAA,UACjB;AAAA,QACF;AAAA,MAEF,UAAE;AACA,uBAAe;AAAA,MACjB;AAMA,eAAS,QAAQ,MAAM,SAAS;AAC9B,YAAI,MAAM;AACR,kBAAQ,MAAM,8BAA8B;AAC5C;AAAA;AAAA,YAAkC,IAAI,QAAQ,aAAW,QAAQ,CAAC;AAAA;AAAA,QACpE;AACA,YAAI,aAAa;AACf,kBAAQ,MAAM,4BAA4B;AAC1C;AAAA;AAAA,YAAkC,IAAI,QAAQ,aAAW,QAAQ,CAAC;AAAA;AAAA,QACpE;AAEA,YAAI,OAAO,YAAY,YAAY;AACjC,mBAAS,QAAQ,QAAQ,IAAI;AAAA,QAC/B,OAAO;AACL,cAAI,CAAC;AAAQ;AAAA,YAAgC,CAAC;AAC9B,UAAC,OAAQ,KAAK,IAAI;AAAA,QACpC;AAEA,wBAAgB;AAEhB,eAAO;AAAA,MACT;AAGA,eAAS,OAAO,OAAO;AACrB,YAAI,MAAM;AACR,kBAAQ,MAAM,+BAA+B;AAC7C;AAAA,QACF;AACA,YAAI,aAAa;AACf,kBAAQ,MAAM,6BAA6B;AAC3C;AAAA,QACF;AAEA,sBAAc,EAAE,MAAM;AACtB,aAAK,UAAU;AAAA,MACjB;AAEA,eAAS,WAAW;AAClB,eAAO;AACP,aAAK,UAAU;AACf,wBAAgB;AAAA,MAClB;AAAA,IACF;AAAA;;;AC1GA,WAAsB,WAAW,KAAK,SAAS,MAAM;AAAA;AAEnD,UAAI,2BAA0B,6BAAM,WAAU,IAAI,YAAY,MAAM;AACpE,UAAI,IAAI,gBAAe,6BAAM;AAAa,iCAAyB;AAEnE,YAAM,UAAU,KAAK,IAAI;AACzB,UAAI,WAAW;AACf,aAAO,MAAM;AAEX,YAAI;AACF,gBAAM,UAAU,YAAY,0BAA0B,KAAK,OAAO,IAAI;AACtE,gBAAM,KAAK,UAAU,MAAM,cAAc,KAAK,IAAI,IAAI,MAAM,MAAM,KAAK,MAAM,GAAG,IAAI;AAEpF,cAAI,GAAG,UAAU,OAAO,GAAG,SAAS,OAClC,GAAG,WAAW,KAAK;AAEnB,gBAAI,CAAC;AAAS,uCAAyB;AACvC,mBAAO;AAAA,UACT;AAEA,gBAAM,IAAI,MAAM,SAAS,GAAG,SAAS,MAAM,GAAG,UAAU,CAAC;AAAA,QAC3D,SAAS,GAAG;AACV,gBAAM,MAAM,CAAC;AAAA,QACf;AAAA,MACF;AAGA,eAAS,MAAM,OAAO;AACpB;AACA,YAAI,UAAU,IAAI,YAAW,6BAAM;AAEnC,cAAM,MAAM,KAAK,IAAI;AACrB,YAAI,UAAU,KAAK;AAAA,UACjB;AAAA,UACA,KAAK,IAAI,MAAM,MAAM,WAAW,CAAC;AAAA,QACnC,KAAK,MAAM,KAAK,OAAO,IAAI;AAE3B,YAAI,OAAO,YAAY,YAAY;AACjC,gBAAM,OAAO,EAAE,OAAO,SAAS,UAAU,WAAW,MAAM,QAAQ;AAClE,kBAAQ,IAAI;AAGZ,cAAI,KAAK,aAAa;AACpB,sBAAU,KAAK,YAAY;AAAA,QAC/B;AAEA,gBAAQ;AAAA,UACN,WAAW,YAAY,WAAW,IAAI,MAAM,MAC5C;AAAA,UAAe;AAAA,UAAS;AAAA,UACxB;AAAA,UACA;AAAA,QAAK;AAEP,eAAO,IAAI,QAAQ,aAAW,WAAW,SAAS,OAAO,CAAC;AAAA,MAC5D;AAAA,IACF;AAAA;AAOA,WAAS,cAAc,KAAK,SAAS,MAAM;AACzC,QAAI,OAAO,QAAQ,UAAU;AAC3B,YAAM,cAAc,GAAG;AAAA,IACzB,WAAW,eAAe,SAAS;AACjC,YAAM,IAAI,QAAQ,cAAc,IAAI,GAAG,GAAG,GAAG;AAAA,IAC/C,WAAW,eAAe,KAAK;AAC7B,YAAM,IAAI,IAAI,cAAc,IAAI,IAAI,CAAC;AAAA,IACvC,OAAO;AACL,YAAM;AAAA;AAAA;AAAA,QACgB;AAAA,SADhB;AAAA,QAEJ,KAAK;AAAA;AAAA,UAA+B,IAAK;AAAA,QAAG;AAAA,MAC9C;AAAA,IACF;AAEA;AAAA;AAAA,MAAwB,MAAO,KAAK,MAAM,GAAG,IAAI;AAAA;AAAA,EACnD;AAGA,WAAS,cAAc,KAAK;AAC1B,UAAM,KAAK,KAAK,IAAI;AACpB,UAAM,aACJ,4BAA4B,OAC3B,IAAI,QAAQ,GAAG,IAAI,IAAI,MAAM,OAAO,MAAM,KAAK,OAAO,KAAK;AAC9D,WAAO;AAAA,EACT;;;ACtFO,WAAS,WAAW,KAAK;AAC9B,WAAO;AAAA,KAAwB,IAAI,QAAQ,mBAAmB,EAAE,EAAE,YAAY,KAAK;AAAA,EACrF;AAEA,MAAM,oBAAoB;AAWnB,WAAS,cAAc,QAAQ;AACpC,aAAS,qBAAqB,MAAM;AACpC,WAAO;AAAA,KAA2B,OAAO,QAAQ,sBAAsB,EAAE,EAAE,YAAY,KAAK;AAAA,EAC9F;AACA,MAAM,uBAAuB;AAO7B,WAAS,qBAAqB,QAAQ;AACpC,aAAS,UAAU,OAAO,KAAK,EAAE,YAAY;AAE7C,QAAI,UAAU,OAAO,WAAW,CAAC,MAAM;AACrC,eAAS,OAAO,MAAM,CAAC;AAEzB,UAAM,YAAY;AAClB,QAAI,UAAU,OAAO,YAAY,WAAW,CAAC,MAAM,GAAG;AACpD,YAAM,UAAU,aAAa,MAAM;AACnC,UAAI,WAAW,QAAQ;AACrB,eAAO,QAAQ;AAAA,IACnB;AAEA,QAAI,UAAU,OAAO,YAAY,OAAO,CAAC,MAAM,GAAG;AAChD,YAAM,UAAU,aAAa,MAAM;AACnC,UAAI,WAAW,QAAQ;AACrB,eAAO,QAAQ;AAEjB,UAAI,UAAU,OAAO,YAAY,SAAS,CAAC,MAAM;AAAG,iBAAS,OAAO,MAAM,CAAC;AAAA;AACtE,iBAAS,OAAO,MAAM,CAAC;AAAA,IAC9B;AAEA,WAAO,UAAU;AAAA,EACnB;AAGO,WAAS,WAAW,KAAK;AAC9B,QAAI,CAAC;AAAK,aAAO;AAEjB,UAAM,IAAI,KAAK,EAAE,YAAY;AAE7B,QAAI,QAAQ;AAAuB,aAAO;AAAA,aACjC,QAAQ;AAAwB,aAAO;AAAA,aACvC,QAAQ;AAAoB,aAAO;AAG5C,WAAO,IAAI,QAAQ,eAAe,EAAE,EAAE,QAAQ,wBAAwB,EAAE;AAAA,EAC1E;AAaO,WAAS,qBAAqB,aAAa;AAGhD,QAAI,SAAS;AACb,QAAI,OAAO;AACX,UAAM,UAAU,YAAY,QAAQ,GAAG;AACvC,QAAI,WAAW,GAAG;AAChB,eAAS,OAAO,YAAY,UAAU,GAAG,OAAO,CAAC,IAAI,KAAK,KAAK,KAAK;AACpE,aAAO,UAAU;AAAA,IACnB;AAEA,UAAM,kBAAkB,YAAY,YAAY,GAAG;AACnD,QAAI,kBAAkB,GAAG;AACvB,gBAAU,OAAO,YAAY,UAAU,IAAI,CAAC,IAAI;AAAA,IAClD,OAAO;AACL,gBAAU,OAAO,YAAY,UAAU,kBAAkB,CAAC,CAAC,IAAI;AAE/D,YAAM,kBAAkB,YAAY,YAAY,KAAK,kBAAkB,CAAC;AACxE,UAAI,kBAAkB,GAAG;AACvB,kBAAU,OAAO,YAAY,UAAU,MAAM,eAAe,CAAC,IAAI,KAAK;AAAA,MACxE,OAAO;AACL,kBAAU,OAAO,YAAY,UAAU,kBAAkB,GAAG,eAAe,CAAC,IAAI,KAAK;AACrF,kBAAU,OAAO,YAAY,UAAU,MAAM,eAAe,CAAC,IAAI,KAAK,KAAK;AAAA,MAC7E;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAGO,WAAS,wBAAwB,QAAQ;AAC9C,aAAS,KAAK,MAAM,SAAS,GAAI;AACjC,UAAM,UAAU,SAAS;AACzB,cAAU,SAAS,WAAW;AAC9B,UAAM,UAAU,SAAS;AACzB,cAAU,SAAS,WAAW;AAC9B,UAAM,QAAQ,SAAS;AACvB,UAAM,QAAQ,SAAS,SAAS;AAEhC,QAAI,OAAO,MAAM,SAAS,SAAS,EAAE,MAAM,CAAC;AAC5C,QAAI,OAAO,QAAQ,SAAS;AAC1B,aAAO,MAAM,SAAS,SAAS,EAAE,MAAM,CAAC,IAAI,MAAM;AAClD,UAAI,OAAO,OAAO;AAChB,cAAM,MAAM,SAAS,IAAI,MAAM;AAC/B,YAAI,MAAM;AACR,gBAAM,OAAO,MAAM;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,IAAI,YAAY,KAAK,CAAC,MAAM;AAAG,YAAM,IAAI,MAAM,CAAC;AAEpD,WAAO;AAAA,EACT;AAKO,WAAS,aAAa,KAAK;AAChC,QAAI,CAAC;AAAK;AACV,UAAM,QAAQ,oBAAoB,KAAK,GAAG;AAC1C,QAAI,CAAC;AAAO;AACZ,WAAO,EAAE,UAAU,MAAM,CAAC,GAAG,QAAQ,MAAM,CAAC,EAAE;AAAA,EAChD;AACA,MAAM,sBAAsB;AAKrB,WAAS,aAAa,KAAK;AAChC,QAAI,CAAC;AAAK;AACV,UAAM,QAAQ,oBAAoB,KAAK,GAAG;AAC1C,QAAI,CAAC,SAAS,CAAC,MAAM,CAAC;AAAG;AACzB,WAAO,EAAE,UAAU,MAAM,CAAC,GAAG,QAAQ,MAAM,CAAC,EAAE;AAAA,EAChD;AACA,MAAM,sBAAsB;;;AClI5B,MAAM,uBAAuB;AAC7B,MAAM,wBAAwB;AAOvB,WAAS,aAAa,OAAO,WAAW;AAC7C,UAAM,YAAW,uCAAW,UAAS;AACrC,WAAO,aAAa,CAAM,WAAU;AAClC,YAAM,aAAa;AAEnB,UAAI;AACJ,UAAI,OAAO;AACT,YAAI,OAAO,UAAU,UAAU;AAC7B,kBAAQ,IAAI,KAAK,KAAK;AAAA,QACxB,WAAW,OAAO,UAAU,UAAU;AACpC,kBAAQ,IAAI,KAAK,KAAK;AAAA,QACxB;AAEA,YAAI,OAAO,SAAS,MAAM,QAAQ,CAAC;AACjC,sBAAY,MAAM,YAAY;AAAA,MAClC;AAEA,YAAM,iBAAiB,oBAAI,IAAI;AAC/B,UAAI,6BAA6B,KAAK,IAAI;AAC1C,UAAI,gDAAgD;AAEpD,aAAO,MAAM;AACX,cAAM,cAAc,MAAM;AAAA,UACxB,cAAc,YAAY,YAAY,YAAY;AAAA,QACpD;AAEA,YAAI,OAAO;AAAS;AAEpB,cAAM,gBAAgB,MAAM,YAAY,KAAK;AAE7C,cAAM,aAAa,cAAc,MAAM,IAAI;AAC3C,YAAI,UAAU;AACd,cAAM,mBAAmB,CAAC;AAC1B,mBAAW,QAAQ,YAAY;AAC7B,cAAI,eAAe,IAAI,IAAI,GAAG;AAC5B;AACA;AAAA,UACF;AAEA,cAAI,CAAC;AAAM;AACX,2BAAiB,KAAK,KAAK,MAAM,IAAI,CAAC;AAAA,QACxC;AAEA,YAAI,iBAAiB,QAAQ;AAC3B,yBAAe,MAAM;AACrB,qBAAW,QAAQ,YAAY;AAC7B,2BAAe,IAAI,IAAI;AAAA,UACzB;AAEA,2DAAiD,iBAAiB;AAAA,QACpE;AAEA,cAAM,qBAAqB,OAAO;AAAA,UAChC,EAAE,SAAS,kBAAkB,QAAQ;AAAA,UACrC,CAAC,QAAQ,SAAS;AAChB,gBAAI,CAAC;AAAQ,qBAAO;AACpB,mBAAO,UAAU,OAAO,QAAQ,OAAO,KAAK,OAAO;AACnD,mBAAO,WAAW,KAAK;AACvB,mBAAO;AAAA,UACT;AAAA,QACF;AACA,YAAI,OAAO;AAAS;AAEpB,cAAM,2BACJ,gDAAgD,yBAChD,KAAK,IAAI,IAAI,6BAA6B,wBAC1C,CAAC,iBAAiB;AAEpB,YAAI,0BAA0B;AAC5B,gBAAM;AACN,cAAI,OAAO;AAAS;AAAA,QACtB;AAGA,YAAI;AAEJ,iBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK;AAChD,gBAAM,QAAQ,iBAAiB,iBAAiB,SAAS,IAAI,CAAC;AAC9D,cAAI,MAAM,WAAW;AACnB,kBAAM,YAAY,IAAI,KAAK,MAAM,SAAS;AAC1C,gBAAI,CAAC,iBAAiB,UAAU,QAAQ,GAAG;AACzC,8BAAgB;AAAA,YAClB,WAAW,iBAAiB,UAAU,QAAQ,KAC5C,UAAU,QAAQ,IAAI,cAAc,QAAQ,GAAG;AAC/C,0BAAY,UAAU,YAAY;AAClC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IAEF,EAAC;AAAA,EACH;AAgBA,WAAuB,oBAAoB,OAAO,WAAW;AAAA;AAzJ7D;AA0JE,YAAM,YAAY,aAAa,OAAO,SAAS;AAC/C;AAAA,mCAA0B,YAA1B,uFAAqC;AAA1B,gBAAM,QAAjB;AACE,gBAAM,iBAAiB,CAAC;AACxB,qBAAW,SAAS,MAAM,SAAS;AACjC,kBAAM,YAAY,IAAI,KAAK,MAAM,SAAS,EAAE,QAAQ;AACpD,kBAAM,UAAU;AAAA,cACd;AAAA,cACA,UAAU,WAAW,MAAM,GAAG;AAAA,cAC9B,aAAa;AAAA,kBACX,WAAM,UAAU,gBAAhB,mBAA8B,OAAM,MAAM,UAAU;AAAA,cAAM;AAAA,cAC5D,UAAU;AAAA,kBACR,iBAAM,UAAU,aAAhB,mBAA0B,gBAA1B,mBAAuC,aACvC,MAAM,UAAU;AAAA,cAAO;AAAA,YAC3B;AACA,2BAAe,KAAK,OAAO;AAAA,UAC7B;AAEA,gBAAM,EAAE,SAAS,eAAe;AAAA,QAClC;AAAA,eAjBA,MA3JF;AA2JE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBF;AAAA;;;AJpKA,MAAM,gBAAgB,IAAI,KAAK,MAAM,IAAI,CAAC;AAE1C,WAAsB,0BAA0B;AAAA;AAC9C,cAAQ,IAAI,qBAAqB;AAEjC,YAAM,gBAAgB,YAAAA,QAAK,QAAQ,WAAW,kCAAkC;AAChF,cAAQ,IAAI,oCAAoC;AAChD,YAAM,iBAAiB,sBAAsB,aAAa;AAC1D,UAAI,UAAU;AACd,UAAI;AACJ,iBAAW,CAAC,UAAU,OAAO,KAAK,OAAO,QAAQ,cAAc,GAAG;AAChE,mBAAW,SAAS,SAAS;AAC3B,cAAI,MAAM,YAAY,SAAS;AAC7B,gBAAI,MAAM,YAAY,cAAc,QAAQ,GAAG;AAC7C,sBAAQ,IAAI,UAAU,OAAO;AAC7B,oBAAM,IAAI,MAAM,0BAA0B,IAAI,KAAK,MAAM,SAAS,CAAC;AAAA,YACrE;AAEA,sBAAU,MAAM;AAChB,yBAAa,EAAE,CAAC,QAAQ,GAAG,QAAQ;AAAA,UACrC;AAAA,QACF;AAAA,MACF;AAEA,cAAQ,IAAI,UAAU,IAAI,KAAK,OAAO,GAAG,KAAK,UAAU;AAExD,cAAQ,IAAI,yBAAyB;AACrC,YAAM,sBAAsB,eAAe,cAAc;AAEzD,UAAI,WAAW,KAAK,IAAI;AAExB,cAAQ,IAAI,2BAA2B,IAAI,KAAK,OAAO,GAAG,KAAK;AAC/D,UAAI;AACJ;AAAA,mCAA0B,oBAAoB,UAAU,KAAM,EAAE,OAAO,CAAC,KAAK,SAAS,WAAW,KAAK,iCAAK,OAAL,EAAW,aAAa,KAAK,EAAC,EAAE,CAAC,IAAvI,0EAA0I;AAA/H,gBAAM,QAAjB;AACE,cAAI,CAAC,MAAM,QAAQ,QAAQ;AACzB,oBAAQ,IAAI,yBAAyB,kBAAkB,IAAI,KAAK,OAAO,CAAC;AACxE;AAAA,UACF;AAEA,2BAAiB,MAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC;AAEvD,kBAAQ;AAAA,YACN,MAAM,QAAQ;AAAA,YACd,iCAAK,MAAM,QAAQ,CAAC,IAApB,EAAuB,WAAW,IAAI,KAAK,MAAM,QAAQ,CAAC,EAAE,SAAS,EAAE,YAAY,EAAE;AAAA,YACrF;AAAA,YACA,iCAAI,MAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC,IAA1C,EAA6C,WAAW,IAAI,KAAK,MAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC,EAAE,SAAS,EAAE,YAAY,EAAE;AAAA,UAAC;AAErI,qBAAW,SAAS,MAAM,SAAS;AACjC,kBAAM,eAAe;AAAA,cACnB,WAAW,MAAM;AAAA,cACjB,aACE,CAAC,MAAM,cAAc,SACnB,MAAM,YAAY,SAAS,KAAK,MAAM,YAAY,MAAM,GAAG,EAAE,IAAI,OAAO,MAAM,YAAY,MAAM,EAAE,IAChG,MAAM;AAAA,cACZ,UAAU,MAAM;AAAA,YAClB;AAEA,kBAAM,WAAW,eAAe,MAAM,QAAQ;AAC9C,gBAAI,CAAC;AAAU,6BAAe,MAAM,QAAQ,IAAI,CAAC,YAAY;AAAA;AACxD,uBAAS,KAAK,YAAY;AAAA,UACjC;AAEA,cAAI,KAAK,IAAI,IAAI,WAAW,KAAO;AACjC,oBAAQ,IAAI,sBAAsB;AAClC,kBAAM,sBAAsB,eAAe,cAAc;AACzD,oBAAQ,IAAI,SAAS;AACrB,uBAAW,KAAK,IAAI;AAAA,UACtB;AAAA,QACF;AAAA,eAnCA,MA1CF;AA0CE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoCF;AAAA;AAQA,WAAe,sBAAsB,eAAe,gBAAgB;AAAA;AAClE,YAAM,eAAe,OAAO,KAAK,cAAc;AAC/C,YAAM,mBAAmB,aAAa,MAAM,EAAE,KAAK,CAAC,MAAM,SAAS,eAAe,IAAI,EAAE,CAAC,EAAE,YAAY,eAAe,IAAI,EAAE,CAAC,EAAE,SAAS;AAExI,UAAI,SAAS,CAAC;AACd,iBAAW,YAAY,kBAAkB;AACvC,YAAI,OAAO,UAAU,KAAO;AAC1B,qBAAW,QAAQ;AACnB,gBAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,EAAE,CAAC;AAAA,QACtD;AACA,eAAO,KAAK,QAAQ;AAAA,MACtB;AAEA,iBAAW;AAEX,eAAS,WAAW,cAAc;AAChC,cAAM,YAAY,qBAAqB,eAAe,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,SAAS;AAC7E,cAAM,WAAW,YAAAA,QAAK,QAAQ,eAAe,SAAS;AACtD,gBAAQ,OAAO,MAAM,MAAM,SAAS;AACpC,cAAM,WAAW,cAAc,QAAQ,gBAAgB,YAAY;AACnE,YAAI,CAAC,UAAAC,QAAG,WAAW,YAAAD,QAAK,QAAQ,QAAQ,CAAC;AAAG,oBAAAC,QAAG,UAAU,YAAAD,QAAK,QAAQ,QAAQ,GAAG,EAAE,WAAW,KAAK,CAAC;AAEpG,gBAAQ,OAAO,MAAM,GAAG;AACxB,cAAM,SAAS,CAAC,UAAAC,QAAG,WAAW,QAAQ,IAAI,SAAa,UAAAA,QAAG,aAAa,UAAU,OAAO;AACxF,YAAI,WAAW,UAAU;AACvB,kBAAQ,OAAO,MAAM,GAAG;AACxB,oBAAAA,QAAG,cAAc,UAAU,QAAQ;AAAA,QACrC;AACA,gBAAQ,OAAO,MAAM,GAAG;AACxB,iBAAS,CAAC;AAAA,MACZ;AAAA,IACF;AAAA;AASA,WAAS,cAAc,WAAW,gBAAgB,cAAc;AAC9D,QAAI,WAAW;AAEf,QAAI;AACJ,QAAI,uBAAuB;AAE3B,eAAW,YAAY,WAAW;AAChC,UAAI;AAAsB,oBAAY;AAAA;AACjC,+BAAuB;AAE5B,kBAAY,KAAK,UAAU,QAAQ,IAAI;AAEvC,YAAM,UAAU,eAAe,QAAQ;AAEvC,UAAI,YAAY;AAChB,UAAI,oBAAmB;AACvB,eAAS,SAAS,GAAG,SAAS,QAAQ,QAAQ,UAAU;AACtD,cAAM,QAAQ,QAAQ,MAAM;AAC5B,cAAM,YAAY,CAAC,SAAS,SAAY,QAAQ,SAAS,CAAC;AAC1D,aAAI,uCAAW,iBAAgB,MAAM,gBAAe,uCAAW,cAAa,MAAM;AAAU;AAE5F,YAAI,mBAAmB;AACrB,8BAAoB;AACpB,2BAAiB,MAAM;AAAA,QACzB,OACK;AACH,sBAAY;AAAA,QACd;AAEA,cAAM,eACJ,YAAY,wBAAwB,MAAM,YAAY,SAAS,IAAI,IAAI,KAAK,MAAM,SAAS,EAAE,YAAY;AAC3G,oBAAY,MAAM;AAElB,oBAAY,KAAK,UAAU,YAAY,IAAI,MAAM,KAAK,UAAU;AAAA,UAC9D,GAAG,MAAM,iBAAgB,uCAAW,eAAc,SAAY,MAAM;AAAA,UACpE,GAAG,MAAM,cAAa,uCAAW,YAAW,SAAY,MAAM;AAAA,QAChE,CAAC;AAAA,MACH;AAEA,kBAAY;AAAA,IACd;AAEA,QAAI,cAAc;AAChB,YAAM,cAAc,eAAe,YAAY;AAC/C,YAAM,eAAe,qBAAqB,YAAY,CAAC,EAAE,SAAS;AAClE,kBAAY,QAAQ,KAAK,UAAU,MAAM,IAAI,MAAM,KAAK,UAAU,OAAO,YAAY;AAAA,IACvF;AACA,gBAAY;AAEZ,WAAO;AAAA,EACT;AAEA,WAAS,qBAAqB,WAAW;AACvC,UAAM,KAAK,IAAI,KAAK,SAAS;AAC7B,UAAMD,QACJ,GAAG,eAAe,IAAI,OACrB,GAAG,YAAY,IAAI,KAAK,MACzB,GAAG,WAAW,IAAI,MAClB,GAAG,YAAY,KACd,MAAM,GAAG,WAAW,GAAG,SAAS,EAAE,MAAM,CAAC,KACzC,MAAM,GAAG,WAAW,GAAG,SAAS,EAAE,MAAM,CAAC,IAAI;AAChD,WAAOA;AAAA,EACT;AAkFA,WAAS,sBAAsB,eAAe;AAI5C,QAAI,YAAY,YAAAE,QAAK;AAAA,MACnB;AAAA,MACA,UAAAC,QAAG,YAAY,YAAAD,QAAK,KAAK,eAAe,MAAM,CAAC,EAAE,IAAI,OAAK,YAAAA,QAAK,QAAQ,eAAe,QAAQ,CAAC,CAAC,EAAE,OAAO,OAAK,EAAE,SAAS,OAAO,CAAC,EAAE,CAAC;AAAA,IAAC;AAGvI,UAAM,iBAAiB,CAAC;AACxB,QAAI,aAAa;AACjB,QAAI,UAAU;AAEd,WAAO,WAAW;AAChB,YAAM,gBAAgB,YAAAA,QAAK,KAAK,eAAe,UAAU,QAAQ,YAAY,EAAE,CAAC;AAEhF,UAAI,CAAC,UAAAC,QAAG,WAAW,aAAa;AAAG;AACnC,cAAQ,OAAO,MAAM,MAAM,SAAS;AACpC,kBAAY;AAEZ,YAAM,MAAM,UAAAA,QAAG,aAAa,eAAe,OAAO;AAClD,iBAAW,IAAI;AACf,cAAQ,OAAO,MAAM,IAAI;AACzB,YAAM,eAAe,KAAK,MAAM,GAAG;AACnC,cAAQ,OAAO,MAAM,GAAG;AACxB,UAAI,iBAAiB;AAErB,iBAAW,CAAC,KAAK,OAAO,KAAK,OAAO,QAAQ,YAAY,GAAG;AACzD,YAAI,QAAQ,QAAQ;AAClB,sBAAY;AACZ,eAAI,uCAAW,WAAW,UAAS,CAAC,UAAU,WAAW,KAAK;AAAG,wBAAY,QAAQ,UAAU,MAAM,CAAC;AACtG;AAAA,QACF;AAEA,cAAM,cAAc,eAAe,GAAG,IAAI,CAAC;AAE3C,YAAI,oBAAoB;AACxB,YAAI,YAAY;AAChB,mBAAW,CAAC,SAAS,OAAO,KAAK,OAAO,QAAQ,OAAO,GAAG;AAExD,cAAI,CAAC,gBAAgB;AACnB,wBAAY,iBAAiB,IAAI,KAAK,OAAO,EAAE,QAAQ;AACvD,gCAAoB;AAAA,UACtB,WAAW,mBAAmB;AAC5B,gCAAoB;AACpB,8BAAkB,qBAAqB,OAAO;AAC9C,wBAAY;AAAA,UACd,OAAO;AACL,yBAAa,qBAAqB,OAAO;AAAA,UAC3C;AAEA,cAAI,YAAY,cAAc,QAAQ,GAAG;AACvC,oBAAQ,IAAI,KAAK,OAAO;AACxB,kBAAM,IAAI,MAAM,0BAA0B,IAAI,KAAK,SAAS,CAAC;AAAA,UAC/D;AAEA,sBAAY,KAAK;AAAA,YACf;AAAA,YACA,aAAa,QAAQ;AAAA,YACrB,UAAU,QAAQ;AAAA,UACpB,CAAC;AAAA,QACH;AAAA,MACF;AAEA;AAAA,IACF;AAEA,YAAQ,IAAI,MAAM,aAAa,YAAY,UAAU,aAAa;AAElE,WAAO;AAAA,EACT;;;AK7UA,WAAsB,wBAAwB;AAAA;AAC5C,cAAQ,IAAI,0BAA0B;AAItC;AAAA,mCAA0B,oBAAoB,IAA9C,0EAAiD;AAAtC,gBAAM,QAAjB;AACE,kBAAQ,IAAI,MAAM,QAAQ,QAAQ,MAAM,QAAQ,CAAC,GAAG,OAAO,MAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC,CAAC;AAClG;AAAA,QACF;AAAA,eAHA,MAZF;AAYE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAIF;AAAA;AAEA,MAAI,OAAO,cAAY,cAAc,OAAO,YAAY,eAAe,OAAO,QAAQ,SAAS,YAAY;AACzG,4BAAwB;AAAA,EAC1B,OAAO;AACL,0BAAsB;AAAA,EACxB;",
  "names": ["path", "fs", "path", "fs"]
}

{
  "version": 3,
  "sources": ["lib/shorten.js", "src/api/indexing/persistence.js", "src/api/akpa.js", "src/api/retry-fetch.js", "lib/plc-directory.js", "src/api/indexing/indexing-run.js", "src/api/indexing/pull-plc-directory.js", "src/api/indexing/index.js", "src/index.js"],
  "sourcesContent": ["// @ts-check\n\n/** @param {string | null | undefined} text */\nexport function likelyDID(text) {\n  return text && (\n    !text.trim().indexOf('did:') ||\n    text.trim().length === 24 && !/[^\\sa-z0-9]/i.test(text)\n  );\n}\n\n/**\n * @param {T} did\n * @returns {T}\n * @template {string | undefined | null} T\n */\nexport function shortenDID(did) {\n  return did && /** @type {T} */(did.replace(_shortenDID_Regex, '').toLowerCase() || undefined);\n}\n\nconst _shortenDID_Regex = /^did\\:plc\\:/;\n\nexport function unwrapShortDID(shortDID) {\n  return !shortDID ? undefined : shortDID.indexOf(':') < 0 ? 'did:plc:' + shortDID.toLowerCase() : shortDID.toLowerCase();\n}\n\n/**\n * @param {T} handle\n * @returns {T}\n * @template {string | undefined | null} T\n */\nexport function shortenHandle(handle) {\n  handle = cheapNormalizeHandle(handle);\n  return handle && /** @type {T} */(handle.replace(_shortenHandle_Regex, '').toLowerCase() || undefined);\n}\nconst _shortenHandle_Regex = /\\.bsky\\.social$/;\n\nexport function unwrapShortHandle(shortHandle) {\n  shortHandle = cheapNormalizeHandle(shortHandle);\n  return !shortHandle ? undefined : shortHandle.indexOf('.') < 0 ? shortHandle.toLowerCase() + '.bsky.social' : shortHandle.toLowerCase();\n}\n\nfunction cheapNormalizeHandle(handle) {\n  handle = handle && handle.trim().toLowerCase();\n\n  if (handle && handle.charCodeAt(0) === 64)\n    handle = handle.slice(1);\n\n  const urlprefix = 'https://bsky.app/';\n  if (handle && handle.lastIndexOf(urlprefix, 0) === 0) {\n    const postURL = breakPostURL(handle);\n    if (postURL && postURL.shortDID)\n      return postURL.shortDID;\n  }\n\n  if (handle && handle.lastIndexOf('at:', 0) === 0) {\n    const feedUri = breakFeedUri(handle);\n    if (feedUri && feedUri.shortDID)\n      return feedUri.shortDID;\n\n    if (handle && handle.lastIndexOf('at://', 0) === 0) handle = handle.slice(5);\n    else handle = handle.slice(3);\n  }\n\n  return handle || undefined;\n}\n\n/** @param {string | undefined | null} pdc */\nexport function shortenPDC(pdc) {\n  if (!pdc) return undefined;\n\n  pdc = pdc.trim().toLowerCase();\n\n  if (pdc === 'https://bsky.social') return '.s';\n  else if (pdc === 'https://bsky.network') return '.n';\n  else if (pdc === 'https://bsky.app') return '.a';\n\n  // https://morel.us-east.host.bsky.network\n  return pdc.replace(/^https:\\/\\//, '').replace(/host\\.bsky\\.network$/, '');\n}\n\nexport function unwrapShortPDC(shortPDC) {\n  if (!shortPDC) return undefined;\n\n  if (shortPDC === '.s') return 'https://bsky.social';\n  else if (shortPDC === '.n') return 'https://bsky.network';\n  else if (shortPDC === '.a') return 'https://bsky.app';\n\n  return 'https://' + shortPDC + 'host.bsky.network';\n}\n\n/**\n * dd+hh:mm:ss like 30+23:59:59\n * @param {string | null | undefined} dtOffsetStr\n */\nexport function parseTimestampOffset(dtOffsetStr) {\n\n  if (!dtOffsetStr) return undefined;\n\n  let offset = 0;\n  let lead = 0;\n  const plusPos = dtOffsetStr.indexOf('+');\n  if (plusPos >= 0) {\n    offset = Number(dtOffsetStr.substring(0, plusPos)) * 24 * 60 * 60 * 1000;\n    lead = plusPos + 1;\n  }\n\n  const secondsColonPos = dtOffsetStr.lastIndexOf(':');\n  if (secondsColonPos < 0) {\n    offset += Number(dtOffsetStr.substring(lead)) * 1000;\n  } else {\n    offset += Number(dtOffsetStr.substring(secondsColonPos + 1)) * 1000;\n\n    const minutesColonPos = dtOffsetStr.lastIndexOf(':', secondsColonPos - 1);\n    if (minutesColonPos < 0) {\n      offset += Number(dtOffsetStr.substring(lead, secondsColonPos)) * 60 * 1000;\n    } else {\n      offset += Number(dtOffsetStr.substring(minutesColonPos + 1, secondsColonPos)) * 60 * 1000;\n      offset += Number(dtOffsetStr.substring(lead, minutesColonPos)) * 60 * 60 * 1000;\n    }\n  }\n\n  return offset;\n}\n\nconst offsetTooLarge = Date.UTC(2022, 1, 1);\n\n/**\n * @param {number} offset\n * @returns dd+hh:mm:ss like 30+23:59:59 or 59:59.999\n */\nexport function timestampOffsetToString(offset) {\n  if (offset > offsetTooLarge) {\n    console.error('timestampOffsetToString: offset too large', offset, new Date(offset));\n  }\n\n  const milliseconds = offset % 1000;\n  offset = (offset - milliseconds) / 1000;\n  const seconds = offset % 60;\n  offset = (offset - seconds) / 60;\n  const minutes = offset % 60;\n  offset = (offset - minutes) / 60;\n  const hours = offset % 24;\n  const days = (offset - hours) / 24;\n\n  let str = (100 + seconds).toString().slice(1);\n  if (milliseconds) {\n    str = str + '.' + (1000 + milliseconds).toString().slice(1).replace(/0+$/, '');\n  }\n\n  if (days + hours + minutes) {\n    str = (100 + minutes).toString().slice(1) + ':' + str;\n    if (days + hours) {\n      str = hours.toString() + ':' + str;\n      if (days) {\n        str = days + '+' + str;\n      }\n    }\n  }\n\n  // no need for leading zero\n  if (str.lastIndexOf('0', 0) === 0) str = str.slice(1);\n\n  return str;\n}\n\n/**\n* @param {string | null | undefined} url\n*/\nexport function breakPostURL(url) {\n  if (!url) return;\n  const match = _breakPostURL_Regex.exec(url);\n  if (!match) return;\n  return { shortDID: match[1], postID: match[2] };\n}\nconst _breakPostURL_Regex = /^http[s]?\\:\\/\\/bsky\\.app\\/profile\\/([a-z0-9\\.\\:]+)\\/post\\/([a-z0-9]+)$/;\n\n/**\n* @param {string | null | undefined} uri\n*/\nexport function breakFeedUri(uri) {\n  if (!uri) return;\n  const match = _breakFeedUri_Regex.exec(uri);\n  if (!match || !match[3]) return;\n  return { shortDID: match[2], postID: match[3] };\n}\nconst _breakFeedUri_Regex = /^at\\:\\/\\/(did:plc:)?([a-z0-9]+)\\/[a-z\\.]+\\/?(.*)?$/;\n", "// @ts-check\n/// <reference path=\"./types.d.ts\" />\n\nimport { parseTimestampOffset } from '../../../lib/shorten';\n\n/** @extends {Map<string, RegistrationHistory>} */\nclass MapExtended extends Map {\n  file = '';\n  next = undefined;\n  earliestRegistration = 0;\n  latestRegistration = 0;\n  latestAction = 0;\n}\n\n/**\n * @typedef {Record<string, HistoryChange[]> & { next?: string }} PersistedStore\n */\n\n/**\n * @param {string} file\n * @param {string} jsonText\n * @returns {RegistrationStore}\n */\nexport function parseRegistrationStore(file, jsonText) {\n  /** @type {PersistedStore} */\n  const bucketMap = JSON.parse(jsonText);\n\n  const store = createEmptyStore(file);\n\n  let carryTimestamp = 0;\n  for (const shortDID in bucketMap) {\n    if (shortDID === 'next') {\n      store.next = bucketMap.next;\n      continue;\n    }\n\n    /** @type {HistoryChange[]} */\n    const registrationHistory = bucketMap[shortDID];\n    for (const entry of registrationHistory) {\n      if (!carryTimestamp) carryTimestamp = new Date(entry.t).getTime();\n      else carryTimestamp += parseTimestampOffset(entry.t) || 0;\n      break;\n    }\n\n    const registrationEntry = {\n      created: carryTimestamp,\n      updates: registrationHistory\n    };\n    updateRanges(carryTimestamp, store);\n    updateLatestCreation(carryTimestamp, store);\n\n    let carryHistoryOffset = 0;\n    let firstHistoryEntry = true;\n    for (const dateOrTimestamp in registrationHistory) {\n      if (firstHistoryEntry) {\n        firstHistoryEntry = false;\n        continue;\n      }\n\n      carryHistoryOffset += parseTimestampOffset(dateOrTimestamp) || 0;\n      updateRanges(carryTimestamp + carryHistoryOffset, store);\n    }\n\n    store.set(shortDID, registrationEntry);\n  }\n\n  return store;\n}\n\n/**\n * @param {number | undefined} prevTimestamp\n * @param {number} timestamp\n */\nexport function deriveStoreFilenameFromTimestamp(prevTimestamp, timestamp) {\n  const dt = new Date(timestamp);\n  const dtPrev = prevTimestamp ? new Date(prevTimestamp) : undefined;\n\n  // 2024-02/4\n  let filename =\n    dt.getUTCFullYear() + '-' +\n    (101 + dt.getUTCMonth()).toString().slice(1) + '/' +\n    dt.getUTCDate();\n\n  if (dt.getUTCFullYear() === dtPrev?.getUTCFullYear() &&\n    dt.getUTCMonth() === dtPrev?.getUTCMonth() &&\n    dt.getUTCDate() === dtPrev?.getUTCDate()) {\n\n    // 2024-02/4-634\n    filename +=\n      '-' + dt.getUTCHours().toString().slice(1) +\n      (101 + dt.getUTCMinutes()).toString().slice(1);\n    \n    if (dt.getUTCHours() === dtPrev.getUTCHours() &&\n      dt.getUTCMinutes() === dtPrev.getUTCMinutes()) {\n      // 2024-02/4-634-12\n      filename +=\n        '-' + (101 + dt.getUTCSeconds()).toString().slice(1);\n\n      if (dt.getUTCSeconds() === dtPrev.getUTCSeconds()) {\n        filename +=\n          '_' + (1001 + dt.getUTCMilliseconds()).toString().slice(1);\n        \n        if (dt.getUTCMilliseconds() === dtPrev.getUTCMilliseconds()) {\n          filename +=\n            '-' + Math.random().toString(36).slice(2, 4);\n        }\n      }\n    }\n  }\n\n  return filename;\n}\n\n/** @param {string} file */\nexport function createEmptyStore(file) {\n  const store = /** @type {RegistrationStore} */(\n    new MapExtended());\n  store.file = file;\n  return store;\n}\n\n/**\n * @param {number | undefined} timestamp\n * @param {RegistrationStore} store\n */\nfunction updateRanges(timestamp, store) {\n  if (!timestamp) return;\n  if (!store.earliestRegistration || timestamp < store.earliestRegistration) store.earliestRegistration = timestamp;\n  if (!store.latestAction || timestamp > store.latestAction) store.latestAction = timestamp;\n}\n\n/**\n * @param {number | undefined} createdTimestamp\n * @param {RegistrationStore} store\n */\nfunction updateLatestCreation(createdTimestamp, store) {\n  if (!createdTimestamp) return;\n  if (!store.latestRegistration || createdTimestamp > store.latestRegistration) store.latestRegistration = createdTimestamp;\n}\n\n\n/**\n * @param {RegistrationStore} store\n * @returns {string}\n */\nexport function stringifyRegistrationStore(store) {\n  let jsonText = '{\\n';\n  let first = true;\n  for (const shortDID of store.keys()) {\n    const registrationEntry = /** @type {RegistrationHistory} */(store.get(shortDID));\n    jsonText += first ?\n      '\"' + shortDID + '\":' + JSON.stringify(registrationEntry.updates) :\n      ',\\n\"' + shortDID + '\":' + JSON.stringify(registrationEntry.updates);\n    first = false;\n  }\n\n  if (store.has('next')) throw new Error('How come store has NEXT?');\n\n  if (store.next) jsonText += ',\\n\"next\":' + JSON.stringify(store.next);\n  jsonText += '\\n}\\n';\n  return jsonText;\n}", "// @ts-check\n\n/**\n * @template [T=any]\n * @template [TBuffer = T[]]\n * @typedef {{\n *  yield: (item: T, combine?: (buffer: TBuffer | undefined, item?: T) => TBuffer) => Promise<void>,\n *  reject: (error: Error) => void,\n *  complete: () => void,\n *  isEnded: boolean,\n *  finally: Promise<void>\n * }} StreamParameters\n */\n\n/**\n * @template [T=any]\n * @template [TBuffer = T[]]\n * @param {(args: StreamParameters<T, TBuffer>) => void } callback\n * @returns {AsyncGenerator<TBuffer, void, unknown>}\n */\nexport async function* streamBuffer(callback) {\n\n  let finallyTrigger = () => { };\n  let stop = false;\n\n  /** @type {TBuffer | undefined} */\n  let buffer;\n\n  let continueTrigger = () => { };\n  /** @type {Promise<void>} */\n  let continuePromise = new Promise(resolve => continueTrigger = resolve);\n\n  let yieldPassedTrigger = () => { };\n  /** @type {Promise<void>} */\n  let yieldPassedPromise = new Promise(resolve => yieldPassedTrigger = resolve);\n\n  /** @type {{ error: Error } | undefined} */\n  let rejectError;\n\n  /** @type {Parameters<typeof callback>[0]} */\n  const args = {\n    yield: yieldFn,\n    reject,\n    complete,\n    isEnded: false,\n    finally: new Promise(resolve => finallyTrigger = resolve)\n  };\n\n  callback(args);\n\n  try {\n    while (!stop) {\n\n      await continuePromise;\n      if (rejectError)\n        throw rejectError.error;\n      if (stop) return;\n\n      continuePromise = new Promise(resolve => continueTrigger = resolve);\n      const yieldBuffer = buffer;\n      buffer = undefined;\n\n      if (yieldBuffer) {\n        yield yieldBuffer;\n\n        const yieldCompleted = yieldPassedTrigger;\n        yieldPassedPromise = new Promise(resolve => yieldPassedTrigger = resolve);\n\n        yieldCompleted();\n      }\n    }\n\n  } finally {\n    finallyTrigger();\n  }\n\n  /**\n   * @param {T} item\n   * @param {(buffer: TBuffer | undefined, item: T) => TBuffer} [combine]\n   */\n  function yieldFn(item, combine) {\n    if (stop) {\n      console.error('Cannot yield after complete.');\n      return /** @type Promise<void> */(new Promise(resolve => resolve()));\n    }\n    if (rejectError) {\n      console.error('Cannot yield after reject.');\n      return /** @type Promise<void> */(new Promise(resolve => resolve()));\n    }\n\n    if (typeof combine === 'function') {\n      buffer = combine(buffer, item);\n    } else {\n      if (!buffer) buffer = /** @type {TBuffer} */([]);\n      /** @type {*} */(buffer).push(item);\n    }\n\n    continueTrigger();\n\n    return yieldPassedPromise;\n  }\n\n  /** @param {Error} error */\n  function reject(error) {\n    if (stop) {\n      console.error('Cannot reject after complete.');\n      return;\n    }\n    if (rejectError) {\n      console.error('Cannot reject after reject.');\n      return;\n    }\n\n    rejectError = { error };\n    args.isEnded = true;\n  }\n\n  function complete() {\n    stop = true;\n    args.isEnded = true;\n    continueTrigger();\n  }\n}\n\n/**\n * @template T\n * @template [TProject = T]\n * @param {AsyncIterable<T>} input\n * @param {(item: T) => TProject} [project]\n */\nexport async function* map(input, project) {\n  for await (const item of input) {\n    const mapped = project ? project(item) : item;\n    yield mapped;\n  }\n}\n\n/**\n * @template T\n * @template [TProject=T extends Array ? T[0] : T]\n * @param {AsyncIterable<T>} input\n * @param {(item: T) => Iterable<TProject> | AsyncIterable<TProject>} [project]\n * @returns {AsyncIterable<TProject>}\n * }}\n */\nexport async function* mergeMap(input, project) {\n  for await (const item of input) {\n    const mapped = project ? project(item) : item;\n    for await (const subItem of /** @type {AsyncIterable<TProject>} */(mapped)) {\n      yield subItem;\n    }\n  }\n}\n\n/**\n * @template T\n * @param {(arg: {\n *  yield: (item: T) => Promise<void>,\n *  reject: (error: Error) => void,\n *  complete: () => void,\n *  finally: Promise<void>\n * }) => void } callback\n */\nexport function streamEvery(callback) {\n  return mergeMap(streamBuffer(callback));\n}\n", "// @ts-check\n\n/**\n * @typedef {{\n *  error: Error,\n *  started: number,\n *  tryCount: number,\n *  waitUntil: number\n * }} RetryArgs\n */\n\n/**\n * @param {Parameters<typeof fetch>[0] & { onretry?: ({}: RetryArgs) => void, nocorsproxy?: boolean }} req\n * @param {Parameters<typeof fetch>[1] & { onretry?: ({}: RetryArgs) => void, nocorsproxy?: boolean }} [init]\n * @returns {ReturnType<typeof fetch>}\n */\nexport async function retryFetch(req, init, ...rest) {\n  // only allow GET requests to use corsproxy\n  let corsproxyMightBeNeeded =\n    !init?.method ||\n    (init?.method || '').toUpperCase() === 'get';\n  if (req.nocorsproxy || init?.nocorsproxy) corsproxyMightBeNeeded = false;\n\n  const started = Date.now();\n  let tryCount = 0;\n  while (true) {\n\n    try {\n      const useCors = tryCount && corsproxyMightBeNeeded && Math.random() > 0.5;\n      const re = useCors ? await fetchWithCors(req, init) : await /** @type {*} */(fetch)(req, init, ...rest);\n\n      if (re.status >= 200 && re.status < 400 ||\n        re.status === 404) {\n        // success or 404 is a sign of request having been processed\n        if (!useCors) corsproxyMightBeNeeded = false;\n        return re;\n      }\n\n      retry(new Error('HTTP' + re.status + ' ' + re.statusText));\n    } catch (e) {\n      await retry(e);\n    }\n  }\n\n  /** @param {Error} error */\n  function retry(error) {\n    tryCount++;\n    let onretry = req.onretry || init?.onretry;\n\n    const now = Date.now();\n    let waitFor = Math.min(\n      30000,\n      Math.max(300, (now - started) / 3)\n    ) * (0.7 + Math.random() * 0.6);\n\n    if (typeof onretry === 'function') {\n      const args = { error, started, tryCount, waitUntil: now + waitFor };\n      onretry(args);\n\n      // allow adjusting the timeout from onretry callback\n      if (args.waitUntil >= now)\n        waitFor = args.waitUntil - now;\n    }\n\n    console.warn(\n      tryCount + ' error' + (tryCount > 1 ? 's' : '') +\n      ', retry in ', waitFor, 'ms ',\n      req,\n      error);\n\n    return new Promise(resolve => setTimeout(resolve, waitFor));\n  }\n}\n\n/**\n * @param {Parameters<typeof fetch>[0]} req\n * @param {Parameters<typeof fetch>[1]} [init]\n * @returns {ReturnType<typeof fetch>}\n */\nfunction fetchWithCors(req, init, ...rest) {\n  if (typeof req === 'string') {\n    req = wrapCorsProxy(req);\n  } else if (req instanceof Request) {\n    req = new Request(wrapCorsProxy(req.url), req);\n  } else if (req instanceof URL) {\n    req = new URL(wrapCorsProxy(req.href));\n  } else {\n    req = {\n      .../** @type {*} */(req),\n      url: wrapCorsProxy(/** @type {*} */(req).url)\n    };\n  }\n\n  return /** @type {*} */(fetch)(req, init, ...rest);\n}\n\n/** @param {string} url */\nfunction wrapCorsProxy(url) {\n  const dt = Date.now();\n  const wrappedURL =\n    'https://corsproxy.io/?' + url +\n    (url.indexOf('?') < 0 ? '?' : '&') + 't' + dt + '=' + (dt + 1);\n  return wrappedURL;\n}", "// @ts-check\n\nimport { streamBuffer } from '../src/api/akpa';\nimport { retryFetch } from '../src/api/retry-fetch';\nimport { shortenDID, shortenHandle, shortenPDC } from './shorten';\n\n/**\n * @typedef {{\n *  fetch?: typeof retryFetch\n * }} Overrides\n */\n\n/**\n * @typedef {{\n *  did: string,\n *  cid: string,\n *  nullified: boolean,\n *  createdAt: string,\n *  operation: {\n *    type: 'create' | 'plc_operation',\n *    sig: string,\n *    alsoKnownAs?: string[],\n *    handle?: string,\n *    prev: string | null,\n *    service?: string,\n *    services?: {\n *      atproto_pds?: {\n *        type: 'AtprotoPersonalDataServer',\n *        endpoint: string\n *      }\n *    },\n *    rotationKeys: any[],\n *    verificationMethods: {}\n *  }\n * }} PLCDirectoryEntry\n */\n\nconst FETCH_AHEAD_MSEC_MAX = 10000;\nconst FETCH_AHEAD_COUNT_MAX = 10000\n\n/**\n * @param {string | Date | number | null} [since]\n * @param {Overrides} [overrides]\n * @returns {AsyncGenerator<{ entries: PLCDirectoryEntry[], overlap: number }>}\n */\nexport function plcDirectory(since, overrides) {\n  const useFetch = overrides?.fetch || fetch;\n  return streamBuffer(async stream => {\n    const EXPORT_URL = 'https://plc.directory/export';\n\n    let sinceTime;\n    if (since) {\n      if (typeof since === 'string') {\n        since = new Date(since);\n      } else if (typeof since === 'number') {\n        since = new Date(since);\n      }\n\n      if (Number.isFinite(since.getTime()))\n        sinceTime = since.toISOString();\n    }\n\n    const lastChunkLines = new Set();\n    let lastWaitedForConsumptionAt = Date.now();\n    let collectedEntriesSinceLastWaitedForConsumption = 0;\n\n    while (true) {\n      const nextChunkRe = await useFetch(\n        EXPORT_URL + (sinceTime ? '?after=' + sinceTime : '')\n      );\n\n      if (stream.isEnded) return;\n\n      const nextChunkText = await nextChunkRe.text();\n\n      const chunkLines = nextChunkText.split('\\n');\n      let overlap = 0;\n      const nextChunkEnitres = [];\n      for (const line of chunkLines) {\n        if (lastChunkLines.has(line)) {\n          overlap++;\n          continue;\n        }\n\n        if (!line) continue;\n        nextChunkEnitres.push(JSON.parse(line));\n      }\n\n      if (nextChunkEnitres.length) {\n        lastChunkLines.clear();\n        for (const line of chunkLines) {\n          lastChunkLines.add(line);\n        }\n\n        collectedEntriesSinceLastWaitedForConsumption += nextChunkEnitres.length;\n      }\n\n      const waitForConsumption = stream.yield(\n        { entries: nextChunkEnitres, overlap },\n        (buffer, item) => {\n          if (!buffer) return item;\n          buffer.entries = buffer.entries.concat(item.entries);\n          buffer.overlap += item.overlap;\n          return buffer;\n        }\n      );\n      if (stream.isEnded) return;\n\n      const shouldWaitForConsumption =\n        collectedEntriesSinceLastWaitedForConsumption > FETCH_AHEAD_COUNT_MAX ||\n        Date.now() - lastWaitedForConsumptionAt > FETCH_AHEAD_MSEC_MAX ||\n        !nextChunkEnitres.length;\n      \n      if (shouldWaitForConsumption) {\n        await waitForConsumption;\n        if (stream.isEnded) return;\n      }\n\n      /** @type {Date | undefined} */\n      let nextSinceTime;\n      // iterate backwards to find timestamp just before latest\n      for (let i = 0; i < nextChunkEnitres.length; i++) {\n        const entry = nextChunkEnitres[nextChunkEnitres.length - i - 1];\n        if (entry.createdAt) {\n          const timestamp = new Date(entry.createdAt);\n          if (!nextSinceTime && timestamp.getTime()) {\n            nextSinceTime = timestamp;\n          } else if (nextSinceTime && timestamp.getTime() &&\n            timestamp.getTime() < nextSinceTime.getTime()) {\n            sinceTime = timestamp.toISOString();\n            break;\n          }\n        }\n      }\n    }\n\n  });\n}\n\n/**\n * @typedef {{\n *  timestamp: number,\n *  shortDID: string,\n *  shortHandle?: string,\n *  shortPDC?: string;\n * }} PLCDirectoryEntryCompact\n */\n\n/**\n * @param {string | Date | number | null} [since]\n * @param {Overrides} [overrides]\n * @returns {AsyncGenerator<{ entries: PLCDirectoryEntryCompact[] }>}\n */\nexport async function* plcDirectoryCompact(since, overrides) {\n  const iteration = plcDirectory(since, overrides);\n  for await (const chunk of iteration) {\n    const compactEntries = [];\n    for (const entry of chunk.entries) {\n      const timestamp = new Date(entry.createdAt).getTime();\n      const compact = {\n        timestamp,\n        shortDID: shortenDID(entry.did),\n        shortHandle: shortenHandle(\n          entry.operation.alsoKnownAs?.[0] || entry.operation.handle),\n        shortPDC: shortenPDC(\n          entry.operation.services?.atproto_pds?.endpoint ||\n          entry.operation.service)\n      };\n      compactEntries.push(compact);\n    }\n\n    yield { entries: compactEntries };\n  }\n}", "// @ts-check\n/// <reference path=\"./types.d.ts\" />\n\nimport { plcDirectoryCompact } from '../../../lib/plc-directory';\nimport { parseTimestampOffset, timestampOffsetToString } from '../../../lib/shorten';\nimport { retryFetch } from '../retry-fetch';\nimport { createEmptyStore, deriveStoreFilenameFromTimestamp, parseRegistrationStore } from './persistence';\n\n/**\n * @typedef {{\n *  read(path: string): Promise<string | undefined>,\n *  fetch?: typeof fetch\n * }} IndexingRunParams\n */\n\n/**\n * @typedef {{\n *  stores: RegistrationStore[],\n *  affectedStores?: RegistrationStore[],\n *  affectedShortDIDs?: string[],\n *  addedShortDIDs?: string[],\n *  earliestRegistration?: number,\n *  latestRegistration?: number,\n *  latestAction?: number,\n *  loadedAllStores?: boolean\n * }} IndexingRunProgress\n */\n\nconst MAX_STORE_SIZE = 50_000;\n\n/**\n * @param {IndexingRunParams} params\n * @returns {AsyncIterable<IndexingRunProgress>}\n */\nexport async function* indexingRun({ read, fetch: useFetch }) {\n  /** @type {RegistrationStore[]} */\n  let stores = [];\n\n  /** @type {Map<string, RegistrationStore>} */\n  const storeByShortDID = new Map();\n  let maxDate = new Date('2022-11-01').getTime();\n  for await (const progress of loadAllStores({ read })) {\n    stores = progress.stores;\n\n    for (const store of stores) {\n      for (const shortDID of store.keys()) {\n        storeByShortDID.set(shortDID, store);\n\n        if (store.latestRegistration > maxDate)\n          maxDate = store.latestRegistration;\n      }\n      // validateStore(store);\n    }\n    yield progress;\n  }\n\n  if (!useFetch) useFetch = (req, opts) => retryFetch(req, { ...opts, nocorsproxy: true });\n\n  console.log(\n    '\\n\\n\\nSTARTING TO PULL DIRECTORY', new Date(maxDate).toISOString());\n  \n  for await (const progress of pullDirectory({ stores, storeByShortDID, startDate: maxDate, fetch: useFetch })) {\n    stores = progress.stores;\n    for (const store of stores) {\n      validateStore(store);\n    }\n\n    yield progress;\n    //break;\n  }\n}\n\n/** @param {RegistrationStore} store */\nfunction validateStore(store) {\n  let firstDate = 0;\n  let firstDateSource = 'uninitialized';\n  const invalidDates = [];\n  for (const { date, source } of dates()) {\n    if (!firstDate) {\n      firstDate = date;\n      firstDateSource = source;\n    }\n\n    if (getMonthStart(date) !== getMonthStart(firstDate)) {\n      invalidDates.push({ date, source });\n    }\n  }\n\n  if (invalidDates.length) {\n    throw new Error(\n      invalidDates.length + ' Invalid dates in store ' + store.file + ':\\n  ' +\n      invalidDates.map(({date, source}) => '[' + new Date(date).toLocaleDateString() + '] ' + source).join('\\n  ') +\n      '\\nfirstDate ' + firstDateSource + ' ' + new Date(firstDate).toLocaleDateString());\n  }\n\n  function* dates() {\n    yield { date: store.earliestRegistration, source: 'earliestRegistration' };\n    yield { date: store.latestRegistration, source: 'latestRegistration' };\n    // yield { date: store.latestAction, source: 'latestAction' };\n\n    let carryTimestamp = 0;\n    for (const shortDID of store.keys()) {\n      if (shortDID === 'next') throw new Error('next should not be a shortDID key');\n      const history = store.get(shortDID);\n      if (!history) throw new Error('No history for shortDID ' + shortDID);\n      yield { date: history.created, source: 'history[' + shortDID + '].created' };\n\n      const update = history.updates[0];\n      if (!carryTimestamp) carryTimestamp = new Date(update.t).getTime();\n      else carryTimestamp += parseTimestampOffset(update.t) || 0;\n\n      // history.created can differ by up to 1 second due to rounding\n      if (Math.abs(carryTimestamp - history.created) > 1001)\n        throw new Error(\n        store.file + ' ' + shortDID + ' ' +\n        'carryTimestamp !== history.created ' +\n        (history.created - carryTimestamp) + 'ms ' +\n        new Date(carryTimestamp).toISOString() + ' !== ' +\n        new Date(history.created).toISOString() + ' ' + shortDID + ' ' + store.file + ' ' + JSON.stringify(update));\n\n      yield { date: carryTimestamp, source: 'history[' + shortDID + '].updates[0] ' + JSON.stringify(update) };\n    }\n  }\n}\n\n/**\n * @param {{\n *  stores: RegistrationStore[],\n *  storeByShortDID: Map<string, RegistrationStore>,\n *  startDate: number,\n *  fetch?: typeof fetch\n * }} _\n * @returns {AsyncIterable<IndexingRunProgress>}\n */\nasync function* pullDirectory({ stores, storeByShortDID, startDate, fetch }) {\n\n  for await (const chunk of plcDirectoryCompact(startDate, { fetch })) {\n    const affectedShortDIDs = new Set();\n    const affectedStores = new Set();\n\n    /** @type {number | undefined} */\n    let earliestRegistration;\n    /** @type {number | undefined} */\n    let latestRegistration;\n    /** @type {number | undefined} */\n    let latestAction;\n\n    /** @type {string[]} */\n    let addedShortDIDs = [];\n\n    for (const entry of chunk.entries) {\n      if (affectedShortDIDs.has(entry.shortDID) && !storeByShortDID.has(entry.shortDID)) {\n        console.warn('How is it possible for affectedShortDIDs.has(entry.shortDID) but not storeByShortDID.has(entry.shortDID) ', entry.shortDID);\n        console.log();\n      }\n\n      // /** @type {HistoryChange} */\n      // const historyChange = {\n      //   h: clampShortHandle(entry.shortHandle),\n      //   p: entry.shortPDC\n      // };\n\n      const existingStore = storeByShortDID.get(entry.shortDID);\n      if (existingStore) {\n        // update history for the already registered shortDID\n        const existingHistory = /** @type {RegistrationHistory} */(\n          existingStore.get(entry.shortDID));\n        if (!addHistoryToExistingShortDID(existingHistory, entry)) {\n          // no update required\n          continue;\n        }\n\n        if (!latestAction || entry.timestamp > latestAction)\n          latestAction = entry.timestamp;\n\n        affectedStores.add(existingStore);\n        affectedShortDIDs.add(entry.shortDID);\n      } else {\n        affectedShortDIDs.add(entry.shortDID);\n\n        /** @type {RegistrationHistory} */\n        const history = {\n          created: entry.timestamp,\n          updates: [{\n            t: new Date(entry.timestamp).toISOString(),\n            h: clampShortHandle(entry.shortHandle),\n            p: entry.shortPDC === '.s' ? undefined : entry.shortPDC\n          }]\n        };\n\n        addedShortDIDs.push(entry.shortDID);\n        if (addedShortDIDs.length > affectedShortDIDs.size) {\n          console.warn('How is it possible for [', addedShortDIDs.length, ']addedShortDIDs.length > [' + affectedShortDIDs.size + ']affectedShortDIDs.size');\n          console.log();\n        }\n\n        if (!earliestRegistration || entry.timestamp < earliestRegistration)\n          earliestRegistration = entry.timestamp;\n        if (!latestRegistration || entry.timestamp > latestRegistration)\n          latestRegistration = entry.timestamp;\n        if (!latestAction || entry.timestamp > latestAction)\n          latestAction = entry.timestamp;\n\n        const { store, insertStoreAt } = findStoreToAddTimestamp(stores, entry.timestamp);\n        if (store) {\n          affectedStores.add(store);\n          // insert into the store\n          if (!store.latestRegistration || entry.timestamp >= store.latestRegistration) {\n            // at the end\n            addNewShortDIDToExistingStoreEnd(store, history, entry);\n          } else {\n            // in the middle: recreate the store\n            addNewShortDIDToExistingStoreMiddle(store, history, entry);\n          }\n\n          storeByShortDID.set(entry.shortDID, store);\n          affectedStores.add(store);\n        } else {\n          // add a new store\n          const { newStore, prevStore } = createNewStoreAddShortDID(stores, insertStoreAt, history, entry);\n\n          storeByShortDID.set(entry.shortDID, newStore);\n          stores.push(newStore);\n\n          affectedStores.add(newStore);\n          if (prevStore) affectedStores.add(prevStore);\n        }\n      }\n   }\n\n    yield {\n      stores: stores,\n      loadedAllStores: true,\n      addedShortDIDs,\n      affectedShortDIDs: Array.from(affectedShortDIDs),\n      affectedStores: Array.from(affectedStores),\n      earliestRegistration,\n      latestRegistration,\n      latestAction\n    };\n\n    earliestRegistration = latestRegistration = latestAction = undefined;\n  }\n}\n\n/**\n * @param {RegistrationHistory} history\n * @param {import('../../../lib/plc-directory').PLCDirectoryEntryCompact} entry\n */\nfunction addHistoryToExistingShortDID(history, entry) {\n  const clampedShortHandle = entry.shortHandle ? clampShortHandle(entry.shortHandle) : undefined;\n  const defaultedPDC = entry.shortPDC === '.s' ? undefined : entry.shortPDC;\n\n  let firstHistoryEntry = true;\n  let carryTimestamp = history.created;\n  let carryClampedShortHandle;\n  let carryPDC;\n  for (let i = 0; i < history.updates.length; i++) {\n    const existingUpdate = history.updates[i];\n    const dateOrTimestamp = existingUpdate.t;\n    let carryTimestampNext =\n      firstHistoryEntry ? carryTimestamp :\n        carryTimestamp += parseTimestampOffset(dateOrTimestamp) || 0;\n\n    if (firstHistoryEntry) firstHistoryEntry = false;\n\n    if (carryTimestampNext > entry.timestamp) {\n      console.warn(\n        'Past history update? ',\n        {\n          entry,\n          history,\n          carryTimestamp: new Date(carryTimestamp),\n          carryTimestampNext: new Date(carryTimestampNext)\n        }\n      );\n\n      const updateRequired = checkUpdateRequired(clampedShortHandle, defaultedPDC, carryClampedShortHandle, carryPDC);\n      if (!updateRequired) return false;\n\n      history.updates.splice(i, 0, {\n        t: timestampOffsetToString(entry.timestamp - carryTimestamp),\n        h: clampedShortHandle === carryClampedShortHandle ? undefined : clampedShortHandle,\n        p: defaultedPDC === carryPDC ? undefined : defaultedPDC\n      });\n\n      return true;\n    }\n\n    carryTimestamp = carryTimestampNext;\n    if (existingUpdate.h) carryClampedShortHandle = existingUpdate.h;\n    if (existingUpdate.p) carryPDC = existingUpdate.p;\n  }\n\n  const updateRequired = checkUpdateRequired(clampedShortHandle, defaultedPDC, carryClampedShortHandle, carryPDC);\n  if (!updateRequired) return false;\n\n  history.updates.push({\n    t: timestampOffsetToString(entry.timestamp - carryTimestamp),\n    h: clampedShortHandle === carryClampedShortHandle ? undefined : clampedShortHandle,\n    p: defaultedPDC === carryPDC ? undefined : defaultedPDC\n  });\n\n  return true;\n}\n\n/**\n * @param {string | undefined} clampedShortHandle\n * @param {string | undefined} defaultedPDC\n * @param {string | undefined} carryClampedShortHandle\n * @param {string | undefined} carryPDC\n */\nfunction checkUpdateRequired(clampedShortHandle, defaultedPDC, carryClampedShortHandle, carryPDC) {\n  const updateRequired =\n    (clampedShortHandle || carryClampedShortHandle) && clampedShortHandle !== carryClampedShortHandle ||\n    (defaultedPDC || carryPDC) && defaultedPDC !== carryPDC;\n  return updateRequired;\n}\n\n/**\n * @param {RegistrationStore} store\n * @param {RegistrationHistory} history\n * @param {import('../../../lib/plc-directory').PLCDirectoryEntryCompact} entry\n */\nfunction addNewShortDIDToExistingStoreEnd(store, history, entry) {\n  store.set(entry.shortDID, history);\n  if (!store.earliestRegistration) store.earliestRegistration = entry.timestamp;\n\n  if (store.latestRegistration) {\n    // store history start as a relative offset from the latest registration\n    history.updates[0].t = timestampOffsetToString(entry.timestamp - store.latestRegistration);\n  }\n  store.latestRegistration = entry.timestamp;\n\n  if (!store.latestAction || entry.timestamp > store.latestAction)\n    store.latestAction = entry.timestamp;\n}\n\n/**\n * @param {RegistrationStore} store\n * @param {RegistrationHistory} history\n * @param {import('../../../lib/plc-directory').PLCDirectoryEntryCompact} entry\n */\nfunction addNewShortDIDToExistingStoreMiddle(store, history, entry) {\n  const entries = Array.from(store.entries());\n  store.clear();\n\n  let added = false;\n  let prevTimestamp = 0;\n  for (const [existingShortDID, existingHistory] of entries) {\n    if (entry.timestamp > existingHistory.created) {\n\n      // we are into history after the entry was created\n      if (!added) {\n        // not added: this is the place to add\n        if (prevTimestamp) {\n          // this condition would happen always,\n          // unless strange situation where the insert is needed before the first entry\n          history.updates[0].t = timestampOffsetToString(entry.timestamp - prevTimestamp);\n        }\n\n        store.set(entry.shortDID, history);\n        prevTimestamp = history.created; // subsequent entry should offset from this newly added\n        added = true;\n      }\n\n      // all subsequent entries should get recalculated timestamps\n      history.updates[0].t = timestampOffsetToString(existingHistory.created - prevTimestamp);\n    }\n    store.set(existingShortDID, existingHistory);\n    prevTimestamp = existingHistory.created;\n  }\n\n  if (!store.has(entry.shortDID)) {\n    console.warn(\n      'This shortDID should not appear at the end according to latestCreation ' +\n      new Date(/** @type {number} */(store.latestRegistration)) +\n      ' being after' + new Date(history.created),\n      { entry, store });\n    store.set(entry.shortDID, history);\n  }\n\n  if (!store.latestAction || entry.timestamp > store.latestAction)\n    store.latestAction = entry.timestamp;\n}\n\n/**\n * @param {RegistrationStore[]} stores\n * @param {number} insertStoreAt\n * @param {RegistrationHistory} history\n * @param {import('../../../lib/plc-directory').PLCDirectoryEntryCompact} entry\n */\nfunction createNewStoreAddShortDID(stores, insertStoreAt, history, entry) {\n  const prevStore = stores[insertStoreAt - 1];\n\n  const file = deriveStoreFilenameFromTimestamp(\n    prevStore?.values().next().value?.created,\n    entry.timestamp);\n\n  const newStore = createEmptyStore(file);\n  newStore.next = prevStore?.next;\n  if (prevStore) prevStore.next = file;\n\n  newStore.latestAction =\n    newStore.latestRegistration =\n    newStore.earliestRegistration =\n    entry.timestamp;\n\n  newStore.set(entry.shortDID, history);\n  return { newStore, prevStore };\n}\n\n/**\n * @param {RegistrationStore[]} stores\n * @param {number} timestamp\n * @returns {{ store: RegistrationStore, insertStoreAt?: undefined } |\n *  {store?: undefined, insertStoreAt: number }}\n */\nfunction findStoreToAddTimestamp(stores, timestamp) {\n  if (!stores?.length) return { insertStoreAt: 0 };\n\n  const latestStore = stores[stores.length - 1];\n  if (!latestStore.earliestRegistration || timestamp >= latestStore.earliestRegistration ||\n    stores.length === 1) {\n    const canAddToExistingStore =\n      latestStore.size < MAX_STORE_SIZE &&\n      getMonthStart(latestStore.latestRegistration) === getMonthStart(timestamp);\n\n    if (canAddToExistingStore) return { store: latestStore };\n    else return { insertStoreAt: stores.length };\n  }\n\n  // timestamp falls before the latestStore, probably need to insert in the past history\n\n  const monthStartTimestamp = getMonthStart(timestamp);\n\n  for (let storeIndex = stores.length - 1; storeIndex > 0; storeIndex--) { // if storeIndex hit zero, that's our store\n    const tryStore = stores[storeIndex];\n    if (timestamp < (tryStore.earliestRegistration || 0)) continue;\n\n    // we found the point!\n    // is this within the store's range?\n\n    if (timestamp < (tryStore.latestAction || 0)) return { store: tryStore };\n\n    const nextStore = stores[storeIndex + 1];\n    const monthStartNext = getMonthStart(nextStore.earliestRegistration || 0);\n\n    if (monthStartTimestamp === monthStartNext) {\n      // nextStore is in the right range\n      // but do we have space?\n      // (allow expanding stores in the middle a little bit)\n      if (nextStore.size < MAX_STORE_SIZE * 1.2) return { store: nextStore };\n      else return { insertStoreAt: storeIndex + 1 };\n    } else {\n      // neither, insert in between\n      return { insertStoreAt: storeIndex + 1 };\n    }\n  }\n\n  return { insertStoreAt: 0 };\n}\n\nconst dt = new Date();\nfunction getMonthStart(timestamp) {\n  dt.setTime(timestamp);\n  dt.setUTCDate(1);\n  dt.setUTCHours(0);\n  dt.setUTCMinutes(0);\n  dt.setUTCSeconds(0);\n  dt.setUTCMilliseconds(0);\n  return dt.getTime();\n}\n\nfunction clampShortHandle(shortHandle) {\n  let clampShortHandle = shortHandle;\n  if (clampShortHandle && clampShortHandle.length > 30)\n    clampShortHandle = clampShortHandle.slice(0, 25) + '...' + clampShortHandle.slice(-2);\n  return clampShortHandle;\n}\n\n/**\n * @param {IndexingRunParams} params\n * @returns {AsyncIterable<IndexingRunProgress>}\n */\nasync function* loadAllStores({ read }) {\n  const inceptionText = await read('inception.json');\n\n  /** @type {string | undefined} */\n  let next = inceptionText ? JSON.parse(inceptionText).next : undefined;\n  if (!next) return yield { stores: [], loadedAllStores: true };\n\n  /** @type {RegistrationStore[]} */\n  const stores = [];\n  /** @type {number | undefined} */\n  let earliestRegistration;\n  /** @type {number | undefined} */\n  let latestRegistration;\n  /** @type {number | undefined} */\n  let latestAction;\n\n  while (next) {\n    const storeText = await read(next + '.json');\n    if (!storeText) break;\n\n    const store = parseRegistrationStore(next, storeText);\n    const affectedShortDIDs = Array.from(store.keys());\n    if (!earliestRegistration || store.earliestRegistration && store.earliestRegistration < earliestRegistration)\n      earliestRegistration = store.earliestRegistration;\n    if (!latestRegistration || store.latestRegistration && store.latestRegistration > latestRegistration)\n      latestRegistration = store.latestRegistration;\n    if (!latestAction || store.latestAction && store.latestAction > latestAction)\n      latestAction = store.latestAction;\n\n    stores.push(store);\n\n    if (!store.next) {\n      yield {\n        loadedAllStores: true,\n        stores, // last yield, return raw underlying array\n        earliestRegistration,\n        latestRegistration,\n        latestAction,\n        affectedStores: [store],\n        affectedShortDIDs,\n        addedShortDIDs: affectedShortDIDs\n      };\n      return;\n    }\n\n    next = store.next;\n    yield {\n      loadedAllStores: false,\n      stores: stores.slice(),\n      earliestRegistration,\n      latestRegistration,\n      latestAction,\n      affectedStores: [store],\n      affectedShortDIDs\n    };\n    earliestRegistration = latestRegistration = latestAction = undefined;\n  }\n\n  yield {\n    loadedAllStores: true,\n    stores, // last yield, return raw underlying array\n    earliestRegistration,\n    latestRegistration,\n    latestAction\n    // no affectedStores or affectedShortDIDs - last read was empty\n  };\n}", "// @ts-check\n\nimport { stringifyRegistrationStore } from './persistence';\n\nexport async function pullPLCDirectoryCompact() {\n  const fs = require('fs');\n  const path = require('path');\n\n  const { indexingRun } = require('./indexing-run');\n\n  console.log('\\n\\n\\nPLC directory CACHE');\n\n  const directoryPath = path.resolve(__dirname, 'src/api/indexing/repos');\n  const rootPath = path.resolve(directoryPath, 'colds-ky-dids-history.github.io');\n\n  const run = indexingRun({\n    read: (localPath) => new Promise((resolve, reject) => {\n      const normalizeLocalPath = localPath.replace(/^\\//, '');\n      const filePath = path.resolve(\n        /^20/.test(normalizeLocalPath) ? directoryPath : rootPath,\n        normalizeLocalPath);\n\n      fs.readFile(filePath, 'utf8', (err, data) => {\n        console.log('  READ>>', filePath, err ? 'ERROR' : 'OK');\n\n        if (err) resolve(undefined);\n        else resolve(data);\n      });\n    })\n  });\n\n  let firstLoaded = true;\n  for await (const progress of run) {\n    const reportProgress = { registrations: 0 };\n    if (progress.stores) {\n      for (const sto of progress.stores)\n        reportProgress.registrations += sto.size;\n    }\n\n    if (progress.affectedStores) reportProgress.affectedStores = progress.affectedStores.map(store => store.file);\n    if (progress.earliestRegistration) reportProgress.earliestRegistration = new Date(progress.earliestRegistration);\n    if (progress.latestRegistration) reportProgress.latestRegistration = new Date(progress.latestRegistration);\n    if (progress.latestAction) reportProgress.latestAction = new Date(progress.latestAction);\n    if (progress.addedShortDIDs) reportProgress.addedShortDIDs = progress.addedShortDIDs.length;\n    if (progress.affectedShortDIDs) reportProgress.affectedShortDIDs = progress.affectedShortDIDs.length;\n\n    if (firstLoaded && progress.loadedAllStores) {\n      firstLoaded = false;\n      console.log('\\n\\n');\n    }\n    console.log(reportProgress);\n\n    // no write back if not all stores are loaded yet\n    if (!progress.loadedAllStores) continue;\n\n    console.log('  WRITE>>');\n\n    if (progress.affectedStores) {\n      const storesInWritingOrder = progress.affectedStores.slice().sort((a, b) =>\n        a.latestRegistration - b.latestRegistration);\n\n      for (const sto of storesInWritingOrder) {\n        const filePath = path.resolve(directoryPath, sto.file + '.json');\n        process.stdout.write('    ' + filePath);\n        const json = stringifyRegistrationStore(sto);\n        await new Promise((resolve, reject) => {\n          fs.writeFile(filePath, json, error => {\n            if (error) reject(error);\n            else resolve(undefined);\n          });\n        });\n        console.log();\n      }\n\n      const inceptionPath = path.resolve(rootPath, 'inception.json');\n      const inceptionStr = JSON.stringify({\n        next: progress.stores[0].file,\n        stores: progress.stores.map(store => store.file)\n      }, null, 2);\n      const currentInception = fs.existsSync(inceptionPath) ?\n        fs.readFileSync(inceptionPath, 'utf8') : '';\n      if (currentInception !== inceptionStr) {\n        process.stdout.write('  ' + path.resolve(rootPath, 'inception.json'));\n        fs.writeFileSync(inceptionPath, inceptionStr);\n        console.log(' ++++ CHANGED.');\n      }\n    }\n\n    console.log(' OK');\n  }\n}\n\n", "// @ts-check\n/// <reference path=\"./types.d.ts\" />\n\nexport { indexingRun } from './indexing-run.js';", "// @ts-check\n\nimport { pullPLCDirectoryCompact } from './api/indexing/pull-plc-directory';\nimport { indexingRun } from './api/indexing';\nimport { retryFetch } from './api/retry-fetch';\n\nasync function pullPLCDirectoryLocal() {\n  console.log('Pulling PLC directory...');\n\n  // TODO: load existing directory from disk\n\n  const run = indexingRun({\n    read: async (localPath) => {\n      return;\n      try {\n        const re = await fetch(\n          location.protocol + '//' +\n          'history.dids.colds.ky' + '/' + localPath.replace(/^\\//, ''));\n        if (re.status !== 200) return;\n        const text = await re.text();\n        return text;\n      } catch (fetchError) {\n        console.warn(localPath, fetchError);\n      }\n    },\n    fetch: retryFetch,\n  });\n\n  let count = 0;\n  for await (const progress of run) {\n    console.log({\n      progress,\n      ...progress,\n      earliestRegistration: progress.earliestRegistration && new Date(progress.earliestRegistration),\n      latestRegistration: progress.latestRegistration && new Date(progress.latestRegistration),\n      latestAction: progress.latestAction && new Date(progress.latestAction),\n      affectedStores: progress.affectedStores?.map(store => store.file),\n      stores: progress.stores?.map(store => store.file),\n    });\n    console.log('\\n\\n\\n');\n    count++;\n    // if (count >= 5)\n    //   break;\n  }\n}\n\nif (typeof require === 'function' && typeof process !== 'undefined' && typeof process.exit === 'function') {\n  console.log('node');\n  // if (require.main === module) {\n  //   console.log('main: run the pullPLCDirectoryCompact');\n  pullPLCDirectoryCompact();\n  // } else {\n  //   console.log('require.main: ', { ['require.main']: require.main, ['module']: module })\n  //   module.exports = { indexingRun }\n  // }\n} else {\n  console.log('browser');\n  pullPLCDirectoryLocal();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeO,WAAS,WAAW,KAAK;AAC9B,WAAO;AAAA,KAAwB,IAAI,QAAQ,mBAAmB,EAAE,EAAE,YAAY,KAAK;AAAA,EACrF;AAaO,WAAS,cAAc,QAAQ;AACpC,aAAS,qBAAqB,MAAM;AACpC,WAAO;AAAA,KAA2B,OAAO,QAAQ,sBAAsB,EAAE,EAAE,YAAY,KAAK;AAAA,EAC9F;AAQA,WAAS,qBAAqB,QAAQ;AACpC,aAAS,UAAU,OAAO,KAAK,EAAE,YAAY;AAE7C,QAAI,UAAU,OAAO,WAAW,CAAC,MAAM;AACrC,eAAS,OAAO,MAAM,CAAC;AAEzB,UAAM,YAAY;AAClB,QAAI,UAAU,OAAO,YAAY,WAAW,CAAC,MAAM,GAAG;AACpD,YAAM,UAAU,aAAa,MAAM;AACnC,UAAI,WAAW,QAAQ;AACrB,eAAO,QAAQ;AAAA,IACnB;AAEA,QAAI,UAAU,OAAO,YAAY,OAAO,CAAC,MAAM,GAAG;AAChD,YAAM,UAAU,aAAa,MAAM;AACnC,UAAI,WAAW,QAAQ;AACrB,eAAO,QAAQ;AAEjB,UAAI,UAAU,OAAO,YAAY,SAAS,CAAC,MAAM;AAAG,iBAAS,OAAO,MAAM,CAAC;AAAA;AACtE,iBAAS,OAAO,MAAM,CAAC;AAAA,IAC9B;AAEA,WAAO,UAAU;AAAA,EACnB;AAGO,WAAS,WAAW,KAAK;AAC9B,QAAI,CAAC;AAAK,aAAO;AAEjB,UAAM,IAAI,KAAK,EAAE,YAAY;AAE7B,QAAI,QAAQ;AAAuB,aAAO;AAAA,aACjC,QAAQ;AAAwB,aAAO;AAAA,aACvC,QAAQ;AAAoB,aAAO;AAG5C,WAAO,IAAI,QAAQ,eAAe,EAAE,EAAE,QAAQ,wBAAwB,EAAE;AAAA,EAC1E;AAgBO,WAAS,qBAAqB,aAAa;AAEhD,QAAI,CAAC;AAAa,aAAO;AAEzB,QAAI,SAAS;AACb,QAAI,OAAO;AACX,UAAM,UAAU,YAAY,QAAQ,GAAG;AACvC,QAAI,WAAW,GAAG;AAChB,eAAS,OAAO,YAAY,UAAU,GAAG,OAAO,CAAC,IAAI,KAAK,KAAK,KAAK;AACpE,aAAO,UAAU;AAAA,IACnB;AAEA,UAAM,kBAAkB,YAAY,YAAY,GAAG;AACnD,QAAI,kBAAkB,GAAG;AACvB,gBAAU,OAAO,YAAY,UAAU,IAAI,CAAC,IAAI;AAAA,IAClD,OAAO;AACL,gBAAU,OAAO,YAAY,UAAU,kBAAkB,CAAC,CAAC,IAAI;AAE/D,YAAM,kBAAkB,YAAY,YAAY,KAAK,kBAAkB,CAAC;AACxE,UAAI,kBAAkB,GAAG;AACvB,kBAAU,OAAO,YAAY,UAAU,MAAM,eAAe,CAAC,IAAI,KAAK;AAAA,MACxE,OAAO;AACL,kBAAU,OAAO,YAAY,UAAU,kBAAkB,GAAG,eAAe,CAAC,IAAI,KAAK;AACrF,kBAAU,OAAO,YAAY,UAAU,MAAM,eAAe,CAAC,IAAI,KAAK,KAAK;AAAA,MAC7E;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAQO,WAAS,wBAAwB,QAAQ;AAC9C,QAAI,SAAS,gBAAgB;AAC3B,cAAQ,MAAM,6CAA6C,QAAQ,IAAI,KAAK,MAAM,CAAC;AAAA,IACrF;AAEA,UAAM,eAAe,SAAS;AAC9B,cAAU,SAAS,gBAAgB;AACnC,UAAM,UAAU,SAAS;AACzB,cAAU,SAAS,WAAW;AAC9B,UAAM,UAAU,SAAS;AACzB,cAAU,SAAS,WAAW;AAC9B,UAAM,QAAQ,SAAS;AACvB,UAAM,QAAQ,SAAS,SAAS;AAEhC,QAAI,OAAO,MAAM,SAAS,SAAS,EAAE,MAAM,CAAC;AAC5C,QAAI,cAAc;AAChB,YAAM,MAAM,OAAO,MAAO,cAAc,SAAS,EAAE,MAAM,CAAC,EAAE,QAAQ,OAAO,EAAE;AAAA,IAC/E;AAEA,QAAI,OAAO,QAAQ,SAAS;AAC1B,aAAO,MAAM,SAAS,SAAS,EAAE,MAAM,CAAC,IAAI,MAAM;AAClD,UAAI,OAAO,OAAO;AAChB,cAAM,MAAM,SAAS,IAAI,MAAM;AAC/B,YAAI,MAAM;AACR,gBAAM,OAAO,MAAM;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,IAAI,YAAY,KAAK,CAAC,MAAM;AAAG,YAAM,IAAI,MAAM,CAAC;AAEpD,WAAO;AAAA,EACT;AAKO,WAAS,aAAa,KAAK;AAChC,QAAI,CAAC;AAAK;AACV,UAAM,QAAQ,oBAAoB,KAAK,GAAG;AAC1C,QAAI,CAAC;AAAO;AACZ,WAAO,EAAE,UAAU,MAAM,CAAC,GAAG,QAAQ,MAAM,CAAC,EAAE;AAAA,EAChD;AAMO,WAAS,aAAa,KAAK;AAChC,QAAI,CAAC;AAAK;AACV,UAAM,QAAQ,oBAAoB,KAAK,GAAG;AAC1C,QAAI,CAAC,SAAS,CAAC,MAAM,CAAC;AAAG;AACzB,WAAO,EAAE,UAAU,MAAM,CAAC,GAAG,QAAQ,MAAM,CAAC,EAAE;AAAA,EAChD;AAxLA,MAmBM,mBAeA,sBA0FA,gBAkDA,qBAWA;AAzLN;AAAA;AAmBA,MAAM,oBAAoB;AAe1B,MAAM,uBAAuB;AA0F7B,MAAM,iBAAiB,KAAK,IAAI,MAAM,GAAG,CAAC;AAkD1C,MAAM,sBAAsB;AAW5B,MAAM,sBAAsB;AAAA;AAAA;;;AClKrB,WAAS,uBAAuB,MAAM,UAAU;AAErD,UAAM,YAAY,KAAK,MAAM,QAAQ;AAErC,UAAM,QAAQ,iBAAiB,IAAI;AAEnC,QAAI,iBAAiB;AACrB,eAAW,YAAY,WAAW;AAChC,UAAI,aAAa,QAAQ;AACvB,cAAM,OAAO,UAAU;AACvB;AAAA,MACF;AAGA,YAAM,sBAAsB,UAAU,QAAQ;AAC9C,iBAAW,SAAS,qBAAqB;AACvC,YAAI,CAAC;AAAgB,2BAAiB,IAAI,KAAK,MAAM,CAAC,EAAE,QAAQ;AAAA;AAC3D,4BAAkB,qBAAqB,MAAM,CAAC,KAAK;AACxD;AAAA,MACF;AAEA,YAAM,oBAAoB;AAAA,QACxB,SAAS;AAAA,QACT,SAAS;AAAA,MACX;AACA,mBAAa,gBAAgB,KAAK;AAClC,2BAAqB,gBAAgB,KAAK;AAE1C,UAAI,qBAAqB;AACzB,UAAI,oBAAoB;AACxB,iBAAW,mBAAmB,qBAAqB;AACjD,YAAI,mBAAmB;AACrB,8BAAoB;AACpB;AAAA,QACF;AAEA,8BAAsB,qBAAqB,eAAe,KAAK;AAC/D,qBAAa,iBAAiB,oBAAoB,KAAK;AAAA,MACzD;AAEA,YAAM,IAAI,UAAU,iBAAiB;AAAA,IACvC;AAEA,WAAO;AAAA,EACT;AAMO,WAAS,iCAAiC,eAAe,WAAW;AACzE,UAAMA,MAAK,IAAI,KAAK,SAAS;AAC7B,UAAM,SAAS,gBAAgB,IAAI,KAAK,aAAa,IAAI;AAGzD,QAAI,WACFA,IAAG,eAAe,IAAI,OACrB,MAAMA,IAAG,YAAY,GAAG,SAAS,EAAE,MAAM,CAAC,IAAI,MAC/CA,IAAG,WAAW;AAEhB,QAAIA,IAAG,eAAe,OAAM,iCAAQ,qBAClCA,IAAG,YAAY,OAAM,iCAAQ,kBAC7BA,IAAG,WAAW,OAAM,iCAAQ,eAAc;AAG1C,kBACE,MAAMA,IAAG,YAAY,EAAE,SAAS,EAAE,MAAM,CAAC,KACxC,MAAMA,IAAG,cAAc,GAAG,SAAS,EAAE,MAAM,CAAC;AAE/C,UAAIA,IAAG,YAAY,MAAM,OAAO,YAAY,KAC1CA,IAAG,cAAc,MAAM,OAAO,cAAc,GAAG;AAE/C,oBACE,OAAO,MAAMA,IAAG,cAAc,GAAG,SAAS,EAAE,MAAM,CAAC;AAErD,YAAIA,IAAG,cAAc,MAAM,OAAO,cAAc,GAAG;AACjD,sBACE,OAAO,OAAOA,IAAG,mBAAmB,GAAG,SAAS,EAAE,MAAM,CAAC;AAE3D,cAAIA,IAAG,mBAAmB,MAAM,OAAO,mBAAmB,GAAG;AAC3D,wBACE,MAAM,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,GAAG,CAAC;AAAA,UAC/C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAGO,WAAS,iBAAiB,MAAM;AACrC,UAAM;AAAA;AAAA,MACJ,IAAI,YAAY;AAAA;AAClB,UAAM,OAAO;AACb,WAAO;AAAA,EACT;AAMA,WAAS,aAAa,WAAW,OAAO;AACtC,QAAI,CAAC;AAAW;AAChB,QAAI,CAAC,MAAM,wBAAwB,YAAY,MAAM;AAAsB,YAAM,uBAAuB;AACxG,QAAI,CAAC,MAAM,gBAAgB,YAAY,MAAM;AAAc,YAAM,eAAe;AAAA,EAClF;AAMA,WAAS,qBAAqB,kBAAkB,OAAO;AACrD,QAAI,CAAC;AAAkB;AACvB,QAAI,CAAC,MAAM,sBAAsB,mBAAmB,MAAM;AAAoB,YAAM,qBAAqB;AAAA,EAC3G;AAOO,WAAS,2BAA2B,OAAO;AAChD,QAAI,WAAW;AACf,QAAI,QAAQ;AACZ,eAAW,YAAY,MAAM,KAAK,GAAG;AACnC,YAAM;AAAA;AAAA,QAAuD,MAAM,IAAI,QAAQ;AAAA;AAC/E,kBAAY,QACV,MAAM,WAAW,OAAO,KAAK,UAAU,kBAAkB,OAAO,IAChE,SAAS,WAAW,OAAO,KAAK,UAAU,kBAAkB,OAAO;AACrE,cAAQ;AAAA,IACV;AAEA,QAAI,MAAM,IAAI,MAAM;AAAG,YAAM,IAAI,MAAM,0BAA0B;AAEjE,QAAI,MAAM;AAAM,kBAAY,eAAe,KAAK,UAAU,MAAM,IAAI;AACpE,gBAAY;AACZ,WAAO;AAAA,EACT;AAjKA,MAMM;AANN;AAAA;AAGA;AAGA,MAAM,cAAN,cAA0B,IAAI;AAAA,QAA9B;AAAA;AACE,sCAAO;AACP;AACA,sDAAuB;AACvB,oDAAqB;AACrB,8CAAe;AAAA;AAAA,MACjB;AAAA;AAAA;;;ACQA,WAAuB,aAAa,UAAU;AAAA;AAE5C,UAAI,iBAAiB,MAAM;AAAA,MAAE;AAC7B,UAAI,OAAO;AAGX,UAAI;AAEJ,UAAI,kBAAkB,MAAM;AAAA,MAAE;AAE9B,UAAI,kBAAkB,IAAI,QAAQ,aAAW,kBAAkB,OAAO;AAEtE,UAAI,qBAAqB,MAAM;AAAA,MAAE;AAEjC,UAAI,qBAAqB,IAAI,QAAQ,aAAW,qBAAqB,OAAO;AAG5E,UAAI;AAGJ,YAAM,OAAO;AAAA,QACX,OAAO;AAAA,QACP;AAAA,QACA;AAAA,QACA,SAAS;AAAA,QACT,SAAS,IAAI,QAAQ,aAAW,iBAAiB,OAAO;AAAA,MAC1D;AAEA,eAAS,IAAI;AAEb,UAAI;AACF,eAAO,CAAC,MAAM;AAEZ,4BAAM;AACN,cAAI;AACF,kBAAM,YAAY;AACpB,cAAI;AAAM;AAEV,4BAAkB,IAAI,QAAQ,aAAW,kBAAkB,OAAO;AAClE,gBAAM,cAAc;AACpB,mBAAS;AAET,cAAI,aAAa;AACf,kBAAM;AAEN,kBAAM,iBAAiB;AACvB,iCAAqB,IAAI,QAAQ,aAAW,qBAAqB,OAAO;AAExE,2BAAe;AAAA,UACjB;AAAA,QACF;AAAA,MAEF,UAAE;AACA,uBAAe;AAAA,MACjB;AAMA,eAAS,QAAQ,MAAM,SAAS;AAC9B,YAAI,MAAM;AACR,kBAAQ,MAAM,8BAA8B;AAC5C;AAAA;AAAA,YAAkC,IAAI,QAAQ,aAAW,QAAQ,CAAC;AAAA;AAAA,QACpE;AACA,YAAI,aAAa;AACf,kBAAQ,MAAM,4BAA4B;AAC1C;AAAA;AAAA,YAAkC,IAAI,QAAQ,aAAW,QAAQ,CAAC;AAAA;AAAA,QACpE;AAEA,YAAI,OAAO,YAAY,YAAY;AACjC,mBAAS,QAAQ,QAAQ,IAAI;AAAA,QAC/B,OAAO;AACL,cAAI,CAAC;AAAQ;AAAA,YAAgC,CAAC;AAC9B,UAAC,OAAQ,KAAK,IAAI;AAAA,QACpC;AAEA,wBAAgB;AAEhB,eAAO;AAAA,MACT;AAGA,eAAS,OAAO,OAAO;AACrB,YAAI,MAAM;AACR,kBAAQ,MAAM,+BAA+B;AAC7C;AAAA,QACF;AACA,YAAI,aAAa;AACf,kBAAQ,MAAM,6BAA6B;AAC3C;AAAA,QACF;AAEA,sBAAc,EAAE,MAAM;AACtB,aAAK,UAAU;AAAA,MACjB;AAEA,eAAS,WAAW;AAClB,eAAO;AACP,aAAK,UAAU;AACf,wBAAgB;AAAA,MAClB;AAAA,IACF;AAAA;AA1HA;AAAA;AAAA;AAAA;;;ACgBA,WAAsB,WAAW,KAAK,SAAS,MAAM;AAAA;AAEnD,UAAI,yBACF,EAAC,6BAAM,aACN,6BAAM,WAAU,IAAI,YAAY,MAAM;AACzC,UAAI,IAAI,gBAAe,6BAAM;AAAa,iCAAyB;AAEnE,YAAM,UAAU,KAAK,IAAI;AACzB,UAAI,WAAW;AACf,aAAO,MAAM;AAEX,YAAI;AACF,gBAAM,UAAU,YAAY,0BAA0B,KAAK,OAAO,IAAI;AACtE,gBAAM,KAAK,UAAU,MAAM,cAAc,KAAK,IAAI,IAAI;AAAA;AAAA,YAAuB,MAAO,KAAK,MAAM,GAAG,IAAI;AAAA;AAEtG,cAAI,GAAG,UAAU,OAAO,GAAG,SAAS,OAClC,GAAG,WAAW,KAAK;AAEnB,gBAAI,CAAC;AAAS,uCAAyB;AACvC,mBAAO;AAAA,UACT;AAEA,gBAAM,IAAI,MAAM,SAAS,GAAG,SAAS,MAAM,GAAG,UAAU,CAAC;AAAA,QAC3D,SAAS,GAAG;AACV,gBAAM,MAAM,CAAC;AAAA,QACf;AAAA,MACF;AAGA,eAAS,MAAM,OAAO;AACpB;AACA,YAAI,UAAU,IAAI,YAAW,6BAAM;AAEnC,cAAM,MAAM,KAAK,IAAI;AACrB,YAAI,UAAU,KAAK;AAAA,UACjB;AAAA,UACA,KAAK,IAAI,MAAM,MAAM,WAAW,CAAC;AAAA,QACnC,KAAK,MAAM,KAAK,OAAO,IAAI;AAE3B,YAAI,OAAO,YAAY,YAAY;AACjC,gBAAM,OAAO,EAAE,OAAO,SAAS,UAAU,WAAW,MAAM,QAAQ;AAClE,kBAAQ,IAAI;AAGZ,cAAI,KAAK,aAAa;AACpB,sBAAU,KAAK,YAAY;AAAA,QAC/B;AAEA,gBAAQ;AAAA,UACN,WAAW,YAAY,WAAW,IAAI,MAAM,MAC5C;AAAA,UAAe;AAAA,UAAS;AAAA,UACxB;AAAA,UACA;AAAA,QAAK;AAEP,eAAO,IAAI,QAAQ,aAAW,WAAW,SAAS,OAAO,CAAC;AAAA,MAC5D;AAAA,IACF;AAAA;AAOA,WAAS,cAAc,KAAK,SAAS,MAAM;AACzC,QAAI,OAAO,QAAQ,UAAU;AAC3B,YAAM,cAAc,GAAG;AAAA,IACzB,WAAW,eAAe,SAAS;AACjC,YAAM,IAAI,QAAQ,cAAc,IAAI,GAAG,GAAG,GAAG;AAAA,IAC/C,WAAW,eAAe,KAAK;AAC7B,YAAM,IAAI,IAAI,cAAc,IAAI,IAAI,CAAC;AAAA,IACvC,OAAO;AACL,YAAM;AAAA;AAAA;AAAA,QACgB;AAAA,SADhB;AAAA,QAEJ,KAAK;AAAA;AAAA,UAA+B,IAAK;AAAA,QAAG;AAAA,MAC9C;AAAA,IACF;AAEA;AAAA;AAAA,MAAwB,MAAO,KAAK,MAAM,GAAG,IAAI;AAAA;AAAA,EACnD;AAGA,WAAS,cAAc,KAAK;AAC1B,UAAMC,MAAK,KAAK,IAAI;AACpB,UAAM,aACJ,2BAA2B,OAC1B,IAAI,QAAQ,GAAG,IAAI,IAAI,MAAM,OAAO,MAAMA,MAAK,OAAOA,MAAK;AAC9D,WAAO;AAAA,EACT;AAvGA;AAAA;AAAA;AAAA;;;AC6CO,WAAS,aAAa,OAAO,WAAW;AAC7C,UAAM,YAAW,uCAAW,UAAS;AACrC,WAAO,aAAa,CAAM,WAAU;AAClC,YAAM,aAAa;AAEnB,UAAI;AACJ,UAAI,OAAO;AACT,YAAI,OAAO,UAAU,UAAU;AAC7B,kBAAQ,IAAI,KAAK,KAAK;AAAA,QACxB,WAAW,OAAO,UAAU,UAAU;AACpC,kBAAQ,IAAI,KAAK,KAAK;AAAA,QACxB;AAEA,YAAI,OAAO,SAAS,MAAM,QAAQ,CAAC;AACjC,sBAAY,MAAM,YAAY;AAAA,MAClC;AAEA,YAAM,iBAAiB,oBAAI,IAAI;AAC/B,UAAI,6BAA6B,KAAK,IAAI;AAC1C,UAAI,gDAAgD;AAEpD,aAAO,MAAM;AACX,cAAM,cAAc,MAAM;AAAA,UACxB,cAAc,YAAY,YAAY,YAAY;AAAA,QACpD;AAEA,YAAI,OAAO;AAAS;AAEpB,cAAM,gBAAgB,MAAM,YAAY,KAAK;AAE7C,cAAM,aAAa,cAAc,MAAM,IAAI;AAC3C,YAAI,UAAU;AACd,cAAM,mBAAmB,CAAC;AAC1B,mBAAW,QAAQ,YAAY;AAC7B,cAAI,eAAe,IAAI,IAAI,GAAG;AAC5B;AACA;AAAA,UACF;AAEA,cAAI,CAAC;AAAM;AACX,2BAAiB,KAAK,KAAK,MAAM,IAAI,CAAC;AAAA,QACxC;AAEA,YAAI,iBAAiB,QAAQ;AAC3B,yBAAe,MAAM;AACrB,qBAAW,QAAQ,YAAY;AAC7B,2BAAe,IAAI,IAAI;AAAA,UACzB;AAEA,2DAAiD,iBAAiB;AAAA,QACpE;AAEA,cAAM,qBAAqB,OAAO;AAAA,UAChC,EAAE,SAAS,kBAAkB,QAAQ;AAAA,UACrC,CAAC,QAAQ,SAAS;AAChB,gBAAI,CAAC;AAAQ,qBAAO;AACpB,mBAAO,UAAU,OAAO,QAAQ,OAAO,KAAK,OAAO;AACnD,mBAAO,WAAW,KAAK;AACvB,mBAAO;AAAA,UACT;AAAA,QACF;AACA,YAAI,OAAO;AAAS;AAEpB,cAAM,2BACJ,gDAAgD,yBAChD,KAAK,IAAI,IAAI,6BAA6B,wBAC1C,CAAC,iBAAiB;AAEpB,YAAI,0BAA0B;AAC5B,gBAAM;AACN,cAAI,OAAO;AAAS;AAAA,QACtB;AAGA,YAAI;AAEJ,iBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK;AAChD,gBAAM,QAAQ,iBAAiB,iBAAiB,SAAS,IAAI,CAAC;AAC9D,cAAI,MAAM,WAAW;AACnB,kBAAM,YAAY,IAAI,KAAK,MAAM,SAAS;AAC1C,gBAAI,CAAC,iBAAiB,UAAU,QAAQ,GAAG;AACzC,8BAAgB;AAAA,YAClB,WAAW,iBAAiB,UAAU,QAAQ,KAC5C,UAAU,QAAQ,IAAI,cAAc,QAAQ,GAAG;AAC/C,0BAAY,UAAU,YAAY;AAClC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IAEF,EAAC;AAAA,EACH;AAgBA,WAAuB,oBAAoB,OAAO,WAAW;AAAA;AAzJ7D;AA0JE,YAAM,YAAY,aAAa,OAAO,SAAS;AAC/C;AAAA,mCAA0B,YAA1B,uFAAqC;AAA1B,gBAAM,QAAjB;AACE,gBAAM,iBAAiB,CAAC;AACxB,qBAAW,SAAS,MAAM,SAAS;AACjC,kBAAM,YAAY,IAAI,KAAK,MAAM,SAAS,EAAE,QAAQ;AACpD,kBAAM,UAAU;AAAA,cACd;AAAA,cACA,UAAU,WAAW,MAAM,GAAG;AAAA,cAC9B,aAAa;AAAA,kBACX,WAAM,UAAU,gBAAhB,mBAA8B,OAAM,MAAM,UAAU;AAAA,cAAM;AAAA,cAC5D,UAAU;AAAA,kBACR,iBAAM,UAAU,aAAhB,mBAA0B,gBAA1B,mBAAuC,aACvC,MAAM,UAAU;AAAA,cAAO;AAAA,YAC3B;AACA,2BAAe,KAAK,OAAO;AAAA,UAC7B;AAEA,gBAAM,EAAE,SAAS,eAAe;AAAA,QAClC;AAAA,eAjBA,MA3JF;AA2JE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBF;AAAA;AA7KA,MAqCM,sBACA;AAtCN;AAAA;AAEA;AACA;AACA;AAiCA,MAAM,uBAAuB;AAC7B,MAAM,wBAAwB;AAAA;AAAA;;;ACtC9B;AAAA;AAAA;AAAA;AAkCA,WAAuB,YAAY,IAA2B;AAAA,wDAA3B,EAAE,MAAM,OAAO,SAAS,GAAG;AAE5D,UAAI,SAAS,CAAC;AAGd,YAAM,kBAAkB,oBAAI,IAAI;AAChC,UAAI,WAAU,oBAAI,KAAK,YAAY,GAAE,QAAQ;AAC7C;AAAA,mCAA6B,cAAc,EAAE,KAAK,CAAC,IAAnD,uFAAsD;AAA3C,gBAAM,WAAjB;AACE,mBAAS,SAAS;AAElB,qBAAW,SAAS,QAAQ;AAC1B,uBAAW,YAAY,MAAM,KAAK,GAAG;AACnC,8BAAgB,IAAI,UAAU,KAAK;AAEnC,kBAAI,MAAM,qBAAqB;AAC7B,0BAAU,MAAM;AAAA,YACpB;AAAA,UAEF;AACA,gBAAM;AAAA,QACR;AAAA,eAbA,MAzCF;AAyCE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA,UAAI,CAAC;AAAU,mBAAW,CAAC,KAAK,SAAS,WAAW,KAAK,iCAAK,OAAL,EAAW,aAAa,KAAK,EAAC;AAEvF,cAAQ;AAAA,QACN;AAAA,QAAoC,IAAI,KAAK,OAAO,EAAE,YAAY;AAAA,MAAC;AAErE;AAAA,iBAAAC,QAAA,WAA6B,cAAc,EAAE,QAAQ,iBAAiB,WAAW,SAAS,OAAO,SAAS,CAAC,IAA3GC,OAAAC,OAAAC,QAAAF,QAAA,EAAAC,QAAA,kBAAAF,MAAA,eAAAC,QAAA,OAA8G;AAAnG,gBAAM,WAAjBC,MAAA;AACE,mBAAS,SAAS;AAClB,qBAAW,SAAS,QAAQ;AAC1B,0BAAc,KAAK;AAAA,UACrB;AAEA,gBAAM;AAAA,QAER;AAAA,eARAA,OA7DF;AA6DE,QAAAC,SAAA,CAAAD;AAAA,gBAAA;AAAA;AAAA,UAAAD,UAAAC,QAAAF,MAAA,8BAAAE,MAAA,KAAAF;AAAA,kBAAA;AAAA,cAAAG;AAAA,kBAAAA,OAAA;AAAA;AAAA;AAAA,IASF;AAAA;AAGA,WAAS,cAAc,OAAO;AAC5B,QAAI,YAAY;AAChB,QAAI,kBAAkB;AACtB,UAAM,eAAe,CAAC;AACtB,eAAW,EAAE,MAAM,OAAO,KAAK,MAAM,GAAG;AACtC,UAAI,CAAC,WAAW;AACd,oBAAY;AACZ,0BAAkB;AAAA,MACpB;AAEA,UAAI,cAAc,IAAI,MAAM,cAAc,SAAS,GAAG;AACpD,qBAAa,KAAK,EAAE,MAAM,OAAO,CAAC;AAAA,MACpC;AAAA,IACF;AAEA,QAAI,aAAa,QAAQ;AACvB,YAAM,IAAI;AAAA,QACR,aAAa,SAAS,6BAA6B,MAAM,OAAO,UAChE,aAAa,IAAI,CAAC,EAAC,MAAM,OAAM,MAAM,MAAM,IAAI,KAAK,IAAI,EAAE,mBAAmB,IAAI,OAAO,MAAM,EAAE,KAAK,MAAM,IAC3G,iBAAiB,kBAAkB,MAAM,IAAI,KAAK,SAAS,EAAE,mBAAmB;AAAA,MAAC;AAAA,IACrF;AAEA,cAAU,QAAQ;AAChB,YAAM,EAAE,MAAM,MAAM,sBAAsB,QAAQ,uBAAuB;AACzE,YAAM,EAAE,MAAM,MAAM,oBAAoB,QAAQ,qBAAqB;AAGrE,UAAI,iBAAiB;AACrB,iBAAW,YAAY,MAAM,KAAK,GAAG;AACnC,YAAI,aAAa;AAAQ,gBAAM,IAAI,MAAM,mCAAmC;AAC5E,cAAM,UAAU,MAAM,IAAI,QAAQ;AAClC,YAAI,CAAC;AAAS,gBAAM,IAAI,MAAM,6BAA6B,QAAQ;AACnE,cAAM,EAAE,MAAM,QAAQ,SAAS,QAAQ,aAAa,WAAW,YAAY;AAE3E,cAAM,SAAS,QAAQ,QAAQ,CAAC;AAChC,YAAI,CAAC;AAAgB,2BAAiB,IAAI,KAAK,OAAO,CAAC,EAAE,QAAQ;AAAA;AAC5D,4BAAkB,qBAAqB,OAAO,CAAC,KAAK;AAGzD,YAAI,KAAK,IAAI,iBAAiB,QAAQ,OAAO,IAAI;AAC/C,gBAAM,IAAI;AAAA,YACV,MAAM,OAAO,MAAM,WAAW,0CAE7B,QAAQ,UAAU,kBAAkB,QACrC,IAAI,KAAK,cAAc,EAAE,YAAY,IAAI,UACzC,IAAI,KAAK,QAAQ,OAAO,EAAE,YAAY,IAAI,MAAM,WAAW,MAAM,MAAM,OAAO,MAAM,KAAK,UAAU,MAAM;AAAA,UAAC;AAE5G,cAAM,EAAE,MAAM,gBAAgB,QAAQ,aAAa,WAAW,kBAAkB,KAAK,UAAU,MAAM,EAAE;AAAA,MACzG;AAAA,IACF;AAAA,EACF;AAWA,WAAgB,cAAc,IAA+C;AAAA,wDAA/C,EAAE,QAAQ,iBAAiB,WAAW,OAAAC,OAAM,GAAG;AAE3E;AAAA,mCAA0B,oBAAoB,WAAW,EAAE,OAAAA,OAAM,CAAC,IAAlE,uFAAqE;AAA1D,gBAAM,QAAjB;AACE,gBAAM,oBAAoB,oBAAI,IAAI;AAClC,gBAAM,iBAAiB,oBAAI,IAAI;AAG/B,cAAI;AAEJ,cAAI;AAEJ,cAAI;AAGJ,cAAI,iBAAiB,CAAC;AAEtB,qBAAW,SAAS,MAAM,SAAS;AACjC,gBAAI,kBAAkB,IAAI,MAAM,QAAQ,KAAK,CAAC,gBAAgB,IAAI,MAAM,QAAQ,GAAG;AACjF,sBAAQ,KAAK,6GAA6G,MAAM,QAAQ;AACxI,sBAAQ,IAAI;AAAA,YACd;AAQA,kBAAM,gBAAgB,gBAAgB,IAAI,MAAM,QAAQ;AACxD,gBAAI,eAAe;AAEjB,oBAAM;AAAA;AAAA,gBACJ,cAAc,IAAI,MAAM,QAAQ;AAAA;AAClC,kBAAI,CAAC,6BAA6B,iBAAiB,KAAK,GAAG;AAEzD;AAAA,cACF;AAEA,kBAAI,CAAC,gBAAgB,MAAM,YAAY;AACrC,+BAAe,MAAM;AAEvB,6BAAe,IAAI,aAAa;AAChC,gCAAkB,IAAI,MAAM,QAAQ;AAAA,YACtC,OAAO;AACL,gCAAkB,IAAI,MAAM,QAAQ;AAGpC,oBAAM,UAAU;AAAA,gBACd,SAAS,MAAM;AAAA,gBACf,SAAS,CAAC;AAAA,kBACR,GAAG,IAAI,KAAK,MAAM,SAAS,EAAE,YAAY;AAAA,kBACzC,GAAG,iBAAiB,MAAM,WAAW;AAAA,kBACrC,GAAG,MAAM,aAAa,OAAO,SAAY,MAAM;AAAA,gBACjD,CAAC;AAAA,cACH;AAEA,6BAAe,KAAK,MAAM,QAAQ;AAClC,kBAAI,eAAe,SAAS,kBAAkB,MAAM;AAClD,wBAAQ,KAAK,4BAA4B,eAAe,QAAQ,+BAA+B,kBAAkB,OAAO,yBAAyB;AACjJ,wBAAQ,IAAI;AAAA,cACd;AAEA,kBAAI,CAAC,wBAAwB,MAAM,YAAY;AAC7C,uCAAuB,MAAM;AAC/B,kBAAI,CAAC,sBAAsB,MAAM,YAAY;AAC3C,qCAAqB,MAAM;AAC7B,kBAAI,CAAC,gBAAgB,MAAM,YAAY;AACrC,+BAAe,MAAM;AAEvB,oBAAM,EAAE,OAAO,cAAc,IAAI,wBAAwB,QAAQ,MAAM,SAAS;AAChF,kBAAI,OAAO;AACT,+BAAe,IAAI,KAAK;AAExB,oBAAI,CAAC,MAAM,sBAAsB,MAAM,aAAa,MAAM,oBAAoB;AAE5E,mDAAiC,OAAO,SAAS,KAAK;AAAA,gBACxD,OAAO;AAEL,sDAAoC,OAAO,SAAS,KAAK;AAAA,gBAC3D;AAEA,gCAAgB,IAAI,MAAM,UAAU,KAAK;AACzC,+BAAe,IAAI,KAAK;AAAA,cAC1B,OAAO;AAEL,sBAAM,EAAE,UAAU,UAAU,IAAI,0BAA0B,QAAQ,eAAe,SAAS,KAAK;AAE/F,gCAAgB,IAAI,MAAM,UAAU,QAAQ;AAC5C,uBAAO,KAAK,QAAQ;AAEpB,+BAAe,IAAI,QAAQ;AAC3B,oBAAI;AAAW,iCAAe,IAAI,SAAS;AAAA,cAC7C;AAAA,YACF;AAAA,UACH;AAEC,gBAAM;AAAA,YACJ;AAAA,YACA,iBAAiB;AAAA,YACjB;AAAA,YACA,mBAAmB,MAAM,KAAK,iBAAiB;AAAA,YAC/C,gBAAgB,MAAM,KAAK,cAAc;AAAA,YACzC;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAEA,iCAAuB,qBAAqB,eAAe;AAAA,QAC7D;AAAA,eA1GA,MAxIF;AAwIE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA2GF;AAAA;AAMA,WAAS,6BAA6B,SAAS,OAAO;AACpD,UAAM,qBAAqB,MAAM,cAAc,iBAAiB,MAAM,WAAW,IAAI;AACrF,UAAM,eAAe,MAAM,aAAa,OAAO,SAAY,MAAM;AAEjE,QAAI,oBAAoB;AACxB,QAAI,iBAAiB,QAAQ;AAC7B,QAAI;AACJ,QAAI;AACJ,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,QAAQ,KAAK;AAC/C,YAAM,iBAAiB,QAAQ,QAAQ,CAAC;AACxC,YAAM,kBAAkB,eAAe;AACvC,UAAI,qBACF,oBAAoB,iBAClB,kBAAkB,qBAAqB,eAAe,KAAK;AAE/D,UAAI;AAAmB,4BAAoB;AAE3C,UAAI,qBAAqB,MAAM,WAAW;AACxC,gBAAQ;AAAA,UACN;AAAA,UACA;AAAA,YACE;AAAA,YACA;AAAA,YACA,gBAAgB,IAAI,KAAK,cAAc;AAAA,YACvC,oBAAoB,IAAI,KAAK,kBAAkB;AAAA,UACjD;AAAA,QACF;AAEA,cAAMC,kBAAiB,oBAAoB,oBAAoB,cAAc,yBAAyB,QAAQ;AAC9G,YAAI,CAACA;AAAgB,iBAAO;AAE5B,gBAAQ,QAAQ,OAAO,GAAG,GAAG;AAAA,UAC3B,GAAG,wBAAwB,MAAM,YAAY,cAAc;AAAA,UAC3D,GAAG,uBAAuB,0BAA0B,SAAY;AAAA,UAChE,GAAG,iBAAiB,WAAW,SAAY;AAAA,QAC7C,CAAC;AAED,eAAO;AAAA,MACT;AAEA,uBAAiB;AACjB,UAAI,eAAe;AAAG,kCAA0B,eAAe;AAC/D,UAAI,eAAe;AAAG,mBAAW,eAAe;AAAA,IAClD;AAEA,UAAM,iBAAiB,oBAAoB,oBAAoB,cAAc,yBAAyB,QAAQ;AAC9G,QAAI,CAAC;AAAgB,aAAO;AAE5B,YAAQ,QAAQ,KAAK;AAAA,MACnB,GAAG,wBAAwB,MAAM,YAAY,cAAc;AAAA,MAC3D,GAAG,uBAAuB,0BAA0B,SAAY;AAAA,MAChE,GAAG,iBAAiB,WAAW,SAAY;AAAA,IAC7C,CAAC;AAED,WAAO;AAAA,EACT;AAQA,WAAS,oBAAoB,oBAAoB,cAAc,yBAAyB,UAAU;AAChG,UAAM,kBACH,sBAAsB,4BAA4B,uBAAuB,4BACzE,gBAAgB,aAAa,iBAAiB;AACjD,WAAO;AAAA,EACT;AAOA,WAAS,iCAAiC,OAAO,SAAS,OAAO;AAC/D,UAAM,IAAI,MAAM,UAAU,OAAO;AACjC,QAAI,CAAC,MAAM;AAAsB,YAAM,uBAAuB,MAAM;AAEpE,QAAI,MAAM,oBAAoB;AAE5B,cAAQ,QAAQ,CAAC,EAAE,IAAI,wBAAwB,MAAM,YAAY,MAAM,kBAAkB;AAAA,IAC3F;AACA,UAAM,qBAAqB,MAAM;AAEjC,QAAI,CAAC,MAAM,gBAAgB,MAAM,YAAY,MAAM;AACjD,YAAM,eAAe,MAAM;AAAA,EAC/B;AAOA,WAAS,oCAAoC,OAAO,SAAS,OAAO;AAClE,UAAM,UAAU,MAAM,KAAK,MAAM,QAAQ,CAAC;AAC1C,UAAM,MAAM;AAEZ,QAAI,QAAQ;AACZ,QAAI,gBAAgB;AACpB,eAAW,CAAC,kBAAkB,eAAe,KAAK,SAAS;AACzD,UAAI,MAAM,YAAY,gBAAgB,SAAS;AAG7C,YAAI,CAAC,OAAO;AAEV,cAAI,eAAe;AAGjB,oBAAQ,QAAQ,CAAC,EAAE,IAAI,wBAAwB,MAAM,YAAY,aAAa;AAAA,UAChF;AAEA,gBAAM,IAAI,MAAM,UAAU,OAAO;AACjC,0BAAgB,QAAQ;AACxB,kBAAQ;AAAA,QACV;AAGA,gBAAQ,QAAQ,CAAC,EAAE,IAAI,wBAAwB,gBAAgB,UAAU,aAAa;AAAA,MACxF;AACA,YAAM,IAAI,kBAAkB,eAAe;AAC3C,sBAAgB,gBAAgB;AAAA,IAClC;AAEA,QAAI,CAAC,MAAM,IAAI,MAAM,QAAQ,GAAG;AAC9B,cAAQ;AAAA,QACN,4EACA,IAAI;AAAA;AAAA,UAA2B,MAAM;AAAA,QAAmB,IACxD,iBAAiB,IAAI,KAAK,QAAQ,OAAO;AAAA,QACzC,EAAE,OAAO,MAAM;AAAA,MAAC;AAClB,YAAM,IAAI,MAAM,UAAU,OAAO;AAAA,IACnC;AAEA,QAAI,CAAC,MAAM,gBAAgB,MAAM,YAAY,MAAM;AACjD,YAAM,eAAe,MAAM;AAAA,EAC/B;AAQA,WAAS,0BAA0B,QAAQ,eAAe,SAAS,OAAO;AAxY1E;AAyYE,UAAM,YAAY,OAAO,gBAAgB,CAAC;AAE1C,UAAM,OAAO;AAAA,OACX,4CAAW,SAAS,OAAO,UAA3B,mBAAkC;AAAA,MAClC,MAAM;AAAA,IAAS;AAEjB,UAAM,WAAW,iBAAiB,IAAI;AACtC,aAAS,OAAO,uCAAW;AAC3B,QAAI;AAAW,gBAAU,OAAO;AAEhC,aAAS,eACP,SAAS,qBACT,SAAS,uBACT,MAAM;AAER,aAAS,IAAI,MAAM,UAAU,OAAO;AACpC,WAAO,EAAE,UAAU,UAAU;AAAA,EAC/B;AAQA,WAAS,wBAAwB,QAAQ,WAAW;AAClD,QAAI,EAAC,iCAAQ;AAAQ,aAAO,EAAE,eAAe,EAAE;AAE/C,UAAM,cAAc,OAAO,OAAO,SAAS,CAAC;AAC5C,QAAI,CAAC,YAAY,wBAAwB,aAAa,YAAY,wBAChE,OAAO,WAAW,GAAG;AACrB,YAAM,wBACJ,YAAY,OAAO,kBACnB,cAAc,YAAY,kBAAkB,MAAM,cAAc,SAAS;AAE3E,UAAI;AAAuB,eAAO,EAAE,OAAO,YAAY;AAAA;AAClD,eAAO,EAAE,eAAe,OAAO,OAAO;AAAA,IAC7C;AAIA,UAAM,sBAAsB,cAAc,SAAS;AAEnD,aAAS,aAAa,OAAO,SAAS,GAAG,aAAa,GAAG,cAAc;AACrE,YAAM,WAAW,OAAO,UAAU;AAClC,UAAI,aAAa,SAAS,wBAAwB;AAAI;AAKtD,UAAI,aAAa,SAAS,gBAAgB;AAAI,eAAO,EAAE,OAAO,SAAS;AAEvE,YAAM,YAAY,OAAO,aAAa,CAAC;AACvC,YAAM,iBAAiB,cAAc,UAAU,wBAAwB,CAAC;AAExE,UAAI,wBAAwB,gBAAgB;AAI1C,YAAI,UAAU,OAAO,iBAAiB;AAAK,iBAAO,EAAE,OAAO,UAAU;AAAA;AAChE,iBAAO,EAAE,eAAe,aAAa,EAAE;AAAA,MAC9C,OAAO;AAEL,eAAO,EAAE,eAAe,aAAa,EAAE;AAAA,MACzC;AAAA,IACF;AAEA,WAAO,EAAE,eAAe,EAAE;AAAA,EAC5B;AAGA,WAAS,cAAc,WAAW;AAChC,OAAG,QAAQ,SAAS;AACpB,OAAG,WAAW,CAAC;AACf,OAAG,YAAY,CAAC;AAChB,OAAG,cAAc,CAAC;AAClB,OAAG,cAAc,CAAC;AAClB,OAAG,mBAAmB,CAAC;AACvB,WAAO,GAAG,QAAQ;AAAA,EACpB;AAEA,WAAS,iBAAiB,aAAa;AACrC,QAAIC,oBAAmB;AACvB,QAAIA,qBAAoBA,kBAAiB,SAAS;AAChD,MAAAA,oBAAmBA,kBAAiB,MAAM,GAAG,EAAE,IAAI,QAAQA,kBAAiB,MAAM,EAAE;AACtF,WAAOA;AAAA,EACT;AAMA,WAAgB,cAAc,IAAU;AAAA,wDAAV,EAAE,KAAK,GAAG;AACtC,YAAM,gBAAgB,kBAAM,KAAK,gBAAgB;AAGjD,UAAI,OAAO,gBAAgB,KAAK,MAAM,aAAa,EAAE,OAAO;AAC5D,UAAI,CAAC;AAAM,eAAO,MAAM,EAAE,QAAQ,CAAC,GAAG,iBAAiB,KAAK;AAG5D,YAAM,SAAS,CAAC;AAEhB,UAAI;AAEJ,UAAI;AAEJ,UAAI;AAEJ,aAAO,MAAM;AACX,cAAM,YAAY,kBAAM,KAAK,OAAO,OAAO;AAC3C,YAAI,CAAC;AAAW;AAEhB,cAAM,QAAQ,uBAAuB,MAAM,SAAS;AACpD,cAAM,oBAAoB,MAAM,KAAK,MAAM,KAAK,CAAC;AACjD,YAAI,CAAC,wBAAwB,MAAM,wBAAwB,MAAM,uBAAuB;AACtF,iCAAuB,MAAM;AAC/B,YAAI,CAAC,sBAAsB,MAAM,sBAAsB,MAAM,qBAAqB;AAChF,+BAAqB,MAAM;AAC7B,YAAI,CAAC,gBAAgB,MAAM,gBAAgB,MAAM,eAAe;AAC9D,yBAAe,MAAM;AAEvB,eAAO,KAAK,KAAK;AAEjB,YAAI,CAAC,MAAM,MAAM;AACf,gBAAM;AAAA,YACJ,iBAAiB;AAAA,YACjB;AAAA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,gBAAgB,CAAC,KAAK;AAAA,YACtB;AAAA,YACA,gBAAgB;AAAA,UAClB;AACA;AAAA,QACF;AAEA,eAAO,MAAM;AACb,cAAM;AAAA,UACJ,iBAAiB;AAAA,UACjB,QAAQ,OAAO,MAAM;AAAA,UACrB;AAAA,UACA;AAAA,UACA;AAAA,UACA,gBAAgB,CAAC,KAAK;AAAA,UACtB;AAAA,QACF;AACA,+BAAuB,qBAAqB,eAAe;AAAA,MAC7D;AAEA,YAAM;AAAA,QACJ,iBAAiB;AAAA,QACjB;AAAA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,MAEF;AAAA,IACF;AAAA;AAviBA,MA4BM,gBAmbA;AA/cN;AAAA;AAGA;AACA;AACA;AACA;AAsBA,MAAM,iBAAiB;AAmbvB,MAAM,KAAK,oBAAI,KAAK;AAAA;AAAA;;;AC7cpB;AAEA,WAAsB,0BAA0B;AAAA;AAC9C,YAAM,KAAK,UAAQ,IAAI;AACvB,YAAM,OAAO,UAAQ,MAAM;AAE3B,YAAM,EAAE,aAAAC,aAAY,IAAI;AAExB,cAAQ,IAAI,2BAA2B;AAEvC,YAAM,gBAAgB,KAAK,QAAQ,WAAW,wBAAwB;AACtE,YAAM,WAAW,KAAK,QAAQ,eAAe,iCAAiC;AAE9E,YAAM,MAAMA,aAAY;AAAA,QACtB,MAAM,CAAC,cAAc,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpD,gBAAM,qBAAqB,UAAU,QAAQ,OAAO,EAAE;AACtD,gBAAM,WAAW,KAAK;AAAA,YACpB,MAAM,KAAK,kBAAkB,IAAI,gBAAgB;AAAA,YACjD;AAAA,UAAkB;AAEpB,aAAG,SAAS,UAAU,QAAQ,CAAC,KAAK,SAAS;AAC3C,oBAAQ,IAAI,YAAY,UAAU,MAAM,UAAU,IAAI;AAEtD,gBAAI;AAAK,sBAAQ,MAAS;AAAA;AACrB,sBAAQ,IAAI;AAAA,UACnB,CAAC;AAAA,QACH,CAAC;AAAA,MACH,CAAC;AAED,UAAI,cAAc;AAClB;AAAA,mCAA6B,MAA7B,0EAAkC;AAAvB,gBAAM,WAAjB;AACE,gBAAM,iBAAiB,EAAE,eAAe,EAAE;AAC1C,cAAI,SAAS,QAAQ;AACnB,uBAAW,OAAO,SAAS;AACzB,6BAAe,iBAAiB,IAAI;AAAA,UACxC;AAEA,cAAI,SAAS;AAAgB,2BAAe,iBAAiB,SAAS,eAAe,IAAI,WAAS,MAAM,IAAI;AAC5G,cAAI,SAAS;AAAsB,2BAAe,uBAAuB,IAAI,KAAK,SAAS,oBAAoB;AAC/G,cAAI,SAAS;AAAoB,2BAAe,qBAAqB,IAAI,KAAK,SAAS,kBAAkB;AACzG,cAAI,SAAS;AAAc,2BAAe,eAAe,IAAI,KAAK,SAAS,YAAY;AACvF,cAAI,SAAS;AAAgB,2BAAe,iBAAiB,SAAS,eAAe;AACrF,cAAI,SAAS;AAAmB,2BAAe,oBAAoB,SAAS,kBAAkB;AAE9F,cAAI,eAAe,SAAS,iBAAiB;AAC3C,0BAAc;AACd,oBAAQ,IAAI,MAAM;AAAA,UACpB;AACA,kBAAQ,IAAI,cAAc;AAG1B,cAAI,CAAC,SAAS;AAAiB;AAE/B,kBAAQ,IAAI,WAAW;AAEvB,cAAI,SAAS,gBAAgB;AAC3B,kBAAM,uBAAuB,SAAS,eAAe,MAAM,EAAE,KAAK,CAAC,GAAG,MACpE,EAAE,qBAAqB,EAAE,kBAAkB;AAE7C,uBAAW,OAAO,sBAAsB;AACtC,oBAAM,WAAW,KAAK,QAAQ,eAAe,IAAI,OAAO,OAAO;AAC/D,sBAAQ,OAAO,MAAM,SAAS,QAAQ;AACtC,oBAAM,OAAO,2BAA2B,GAAG;AAC3C,oBAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AACrC,mBAAG,UAAU,UAAU,MAAM,CAAAC,WAAS;AACpC,sBAAIA;AAAO,2BAAOA,MAAK;AAAA;AAClB,4BAAQ,MAAS;AAAA,gBACxB,CAAC;AAAA,cACH,CAAC;AACD,sBAAQ,IAAI;AAAA,YACd;AAEA,kBAAM,gBAAgB,KAAK,QAAQ,UAAU,gBAAgB;AAC7D,kBAAM,eAAe,KAAK,UAAU;AAAA,cAClC,MAAM,SAAS,OAAO,CAAC,EAAE;AAAA,cACzB,QAAQ,SAAS,OAAO,IAAI,WAAS,MAAM,IAAI;AAAA,YACjD,GAAG,MAAM,CAAC;AACV,kBAAM,mBAAmB,GAAG,WAAW,aAAa,IAClD,GAAG,aAAa,eAAe,MAAM,IAAI;AAC3C,gBAAI,qBAAqB,cAAc;AACrC,sBAAQ,OAAO,MAAM,OAAO,KAAK,QAAQ,UAAU,gBAAgB,CAAC;AACpE,iBAAG,cAAc,eAAe,YAAY;AAC5C,sBAAQ,IAAI,gBAAgB;AAAA,YAC9B;AAAA,UACF;AAEA,kBAAQ,IAAI,KAAK;AAAA,QACnB;AAAA,eAzDA,MAhCF;AAgCE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA0DF;AAAA;;;ACvFA;;;ACCA;AAEA,WAAe,wBAAwB;AAAA;AANvC;AAOE,cAAQ,IAAI,0BAA0B;AAItC,YAAM,MAAM,YAAY;AAAA,QACtB,MAAM,CAAO,cAAc;AACzB;AACA,cAAI;AACF,kBAAM,KAAK,MAAM;AAAA,cACf,SAAS,WAAW,6BACY,UAAU,QAAQ,OAAO,EAAE;AAAA,YAAC;AAC9D,gBAAI,GAAG,WAAW;AAAK;AACvB,kBAAM,OAAO,MAAM,GAAG,KAAK;AAC3B,mBAAO;AAAA,UACT,SAAS,YAAY;AACnB,oBAAQ,KAAK,WAAW,UAAU;AAAA,UACpC;AAAA,QACF;AAAA,QACA,OAAO;AAAA,MACT,CAAC;AAED,UAAI,QAAQ;AACZ;AAAA,mCAA6B,MAA7B,0EAAkC;AAAvB,gBAAM,WAAjB;AACE,kBAAQ,IAAI;AAAA,YACV;AAAA,aACG,WAFO;AAAA,YAGV,sBAAsB,SAAS,wBAAwB,IAAI,KAAK,SAAS,oBAAoB;AAAA,YAC7F,oBAAoB,SAAS,sBAAsB,IAAI,KAAK,SAAS,kBAAkB;AAAA,YACvF,cAAc,SAAS,gBAAgB,IAAI,KAAK,SAAS,YAAY;AAAA,YACrE,iBAAgB,cAAS,mBAAT,mBAAyB,IAAI,WAAS,MAAM;AAAA,YAC5D,SAAQ,cAAS,WAAT,mBAAiB,IAAI,WAAS,MAAM;AAAA,UAC9C,EAAC;AACD,kBAAQ,IAAI,QAAQ;AACpB;AAAA,QAGF;AAAA,eAdA,MA7BF;AA6BE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeF;AAAA;AAEA,MAAI,OAAO,cAAY,cAAc,OAAO,YAAY,eAAe,OAAO,QAAQ,SAAS,YAAY;AACzG,YAAQ,IAAI,MAAM;AAGlB,4BAAwB;AAAA,EAK1B,OAAO;AACL,YAAQ,IAAI,SAAS;AACrB,0BAAsB;AAAA,EACxB;",
  "names": ["dt", "dt", "iter", "more", "temp", "error", "fetch", "updateRequired", "clampShortHandle", "indexingRun", "error"]
}

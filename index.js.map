{
  "version": 3,
  "sources": ["src/api/akpa.js", "src/api/retry-fetch.js", "lib/shorten.js", "lib/plc-directory.js", "src/api/indexing/persistence.js", "src/api/indexing/indexing-run.js", "src/api/indexing/pull-plc-directory.js", "src/api/indexing/index.js", "src/index.js"],
  "sourcesContent": ["// @ts-check\n\n/**\n * @template [T=any]\n * @template [TBuffer = T[]]\n * @typedef {{\n *  yield: (item: T, combine?: (buffer: TBuffer | undefined, item?: T) => TBuffer) => Promise<void>,\n *  reject: (error: Error) => void,\n *  complete: () => void,\n *  isEnded: boolean,\n *  finally: Promise<void>\n * }} StreamParameters\n */\n\n/**\n * @template [T=any]\n * @template [TBuffer = T[]]\n * @param {(args: StreamParameters<T, TBuffer>) => void } callback\n * @returns {AsyncGenerator<TBuffer, void, unknown>}\n */\nexport async function* streamBuffer(callback) {\n\n  let finallyTrigger = () => { };\n  let stop = false;\n\n  /** @type {TBuffer | undefined} */\n  let buffer;\n\n  let continueTrigger = () => { };\n  /** @type {Promise<void>} */\n  let continuePromise = new Promise(resolve => continueTrigger = resolve);\n\n  let yieldPassedTrigger = () => { };\n  /** @type {Promise<void>} */\n  let yieldPassedPromise = new Promise(resolve => yieldPassedTrigger = resolve);\n\n  /** @type {{ error: Error } | undefined} */\n  let rejectError;\n\n  /** @type {Parameters<typeof callback>[0]} */\n  const args = {\n    yield: yieldFn,\n    reject,\n    complete,\n    isEnded: false,\n    finally: new Promise(resolve => finallyTrigger = resolve)\n  };\n\n  callback(args);\n\n  try {\n    while (!stop) {\n\n      await continuePromise;\n      if (rejectError)\n        throw rejectError.error;\n      if (stop) return;\n\n      continuePromise = new Promise(resolve => continueTrigger = resolve);\n      const yieldBuffer = buffer;\n      buffer = undefined;\n\n      if (yieldBuffer) {\n        yield yieldBuffer;\n\n        const yieldCompleted = yieldPassedTrigger;\n        yieldPassedPromise = new Promise(resolve => yieldPassedTrigger = resolve);\n\n        yieldCompleted();\n      }\n    }\n\n  } finally {\n    finallyTrigger();\n  }\n\n  /**\n   * @param {T} item\n   * @param {(buffer: TBuffer | undefined, item: T) => TBuffer} [combine]\n   */\n  function yieldFn(item, combine) {\n    if (stop) {\n      console.error('Cannot yield after complete.');\n      return /** @type Promise<void> */(new Promise(resolve => resolve()));\n    }\n    if (rejectError) {\n      console.error('Cannot yield after reject.');\n      return /** @type Promise<void> */(new Promise(resolve => resolve()));\n    }\n\n    if (typeof combine === 'function') {\n      buffer = combine(buffer, item);\n    } else {\n      if (!buffer) buffer = /** @type {TBuffer} */([]);\n      /** @type {*} */(buffer).push(item);\n    }\n\n    continueTrigger();\n\n    return yieldPassedPromise;\n  }\n\n  /** @param {Error} error */\n  function reject(error) {\n    if (stop) {\n      console.error('Cannot reject after complete.');\n      return;\n    }\n    if (rejectError) {\n      console.error('Cannot reject after reject.');\n      return;\n    }\n\n    rejectError = { error };\n    args.isEnded = true;\n  }\n\n  function complete() {\n    stop = true;\n    args.isEnded = true;\n    continueTrigger();\n  }\n}\n\n/**\n * @template T\n * @template [TProject = T]\n * @param {AsyncIterable<T>} input\n * @param {(item: T) => TProject} [project]\n */\nexport async function* map(input, project) {\n  for await (const item of input) {\n    const mapped = project ? project(item) : item;\n    yield mapped;\n  }\n}\n\n/**\n * @template T\n * @template [TProject=T extends Array ? T[0] : T]\n * @param {AsyncIterable<T>} input\n * @param {(item: T) => Iterable<TProject> | AsyncIterable<TProject>} [project]\n * @returns {AsyncIterable<TProject>}\n * }}\n */\nexport async function* mergeMap(input, project) {\n  for await (const item of input) {\n    const mapped = project ? project(item) : item;\n    for await (const subItem of /** @type {AsyncIterable<TProject>} */(mapped)) {\n      yield subItem;\n    }\n  }\n}\n\n/**\n * @template T\n * @param {(arg: {\n *  yield: (item: T) => Promise<void>,\n *  reject: (error: Error) => void,\n *  complete: () => void,\n *  finally: Promise<void>\n * }) => void } callback\n */\nexport function streamEvery(callback) {\n  return mergeMap(streamBuffer(callback));\n}\n", "// @ts-check\n\n/**\n * @typedef {{\n *  error: Error,\n *  started: number,\n *  tryCount: number,\n *  waitUntil: number\n * }} RetryArgs\n */\n\n/**\n * @param {Parameters<typeof fetch>[0] & { onretry?: ({}: RetryArgs) => void, nocorsproxy?: boolean }} req\n * @param {Parameters<typeof fetch>[1] & { onretry?: ({}: RetryArgs) => void, nocorsproxy?: boolean }} [init]\n * @returns {ReturnType<typeof fetch>}\n */\nexport async function retryFetch(req, init, ...rest) {\n  // only allow GET requests to use corsproxy\n  let corsproxyMightBeNeeded = (init?.method || '').toUpperCase() === 'get';\n  if (req.nocorsproxy || init?.nocorsproxy) corsproxyMightBeNeeded = false;\n\n  const started = Date.now();\n  let tryCount = 0;\n  while (true) {\n\n    try {\n      const useCors = tryCount && corsproxyMightBeNeeded && Math.random() > 0.5;\n      const re = useCors ? await fetchWithCors(req, init) : await fetch(req, init, ...rest);\n\n      if (re.status >= 200 && re.status < 400 ||\n        re.status === 404) {\n        // success or 404 is a sign of request having been processed\n        if (!useCors) corsproxyMightBeNeeded = false;\n        return re;\n      }\n\n      retry(new Error('HTTP' + re.status + ' ' + re.statusText));\n    } catch (e) {\n      await retry(e);\n    }\n  }\n\n  /** @param {Error} error */\n  function retry(error) {\n    tryCount++;\n    let onretry = req.onretry || init?.onretry;\n\n    const now = Date.now();\n    let waitFor = Math.min(\n      30000,\n      Math.max(300, (now - started) / 3)\n    ) * (0.7 + Math.random() * 0.6);\n\n    if (typeof onretry === 'function') {\n      const args = { error, started, tryCount, waitUntil: now + waitFor };\n      onretry(args);\n\n      // allow adjusting the timeout from onretry callback\n      if (args.waitUntil >= now)\n        waitFor = args.waitUntil - now;\n    }\n\n    console.warn(\n      tryCount + ' error' + (tryCount > 1 ? 's' : '') +\n      ', retry in ', waitFor, 'ms ',\n      req,\n      error);\n\n    return new Promise(resolve => setTimeout(resolve, waitFor));\n  }\n}\n\n/**\n * @param {Parameters<typeof fetch>[0]} req\n * @param {Parameters<typeof fetch>[1]} [init]\n * @returns {ReturnType<typeof fetch>}\n */\nfunction fetchWithCors(req, init, ...rest) {\n  if (typeof req === 'string') {\n    req = wrapCorsProxy(req);\n  } else if (req instanceof Request) {\n    req = new Request(wrapCorsProxy(req.url), req);\n  } else if (req instanceof URL) {\n    req = new URL(wrapCorsProxy(req.href));\n  } else {\n    req = {\n      .../** @type {*} */(req),\n      url: wrapCorsProxy(/** @type {*} */(req).url)\n    };\n  }\n\n  return /** @type {*} */(fetch)(req, init, ...rest);\n}\n\n/** @param {string} url */\nfunction wrapCorsProxy(url) {\n  const dt = Date.now();\n  const wrappedURL =\n    'https://corsproxy.com/?' + url +\n    (url.indexOf('?') < 0 ? '?' : '&') + 't' + dt + '=' + (dt + 1);\n  return wrappedURL;\n}", "// @ts-check\n\n/** @param {string | null | undefined} text */\nexport function likelyDID(text) {\n  return text && (\n    !text.trim().indexOf('did:') ||\n    text.trim().length === 24 && !/[^\\sa-z0-9]/i.test(text)\n  );\n}\n\n/**\n * @param {T} did\n * @returns {T}\n * @template {string | undefined | null} T\n */\nexport function shortenDID(did) {\n  return did && /** @type {T} */(did.replace(_shortenDID_Regex, '').toLowerCase() || undefined);\n}\n\nconst _shortenDID_Regex = /^did\\:plc\\:/;\n\nexport function unwrapShortDID(shortDID) {\n  return !shortDID ? undefined : shortDID.indexOf(':') < 0 ? 'did:plc:' + shortDID.toLowerCase() : shortDID.toLowerCase();\n}\n\n/**\n * @param {T} handle\n * @returns {T}\n * @template {string | undefined | null} T\n */\nexport function shortenHandle(handle) {\n  handle = cheapNormalizeHandle(handle);\n  return handle && /** @type {T} */(handle.replace(_shortenHandle_Regex, '').toLowerCase() || undefined);\n}\nconst _shortenHandle_Regex = /\\.bsky\\.social$/;\n\nexport function unwrapShortHandle(shortHandle) {\n  shortHandle = cheapNormalizeHandle(shortHandle);\n  return !shortHandle ? undefined : shortHandle.indexOf('.') < 0 ? shortHandle.toLowerCase() + '.bsky.social' : shortHandle.toLowerCase();\n}\n\nfunction cheapNormalizeHandle(handle) {\n  handle = handle && handle.trim().toLowerCase();\n\n  if (handle && handle.charCodeAt(0) === 64)\n    handle = handle.slice(1);\n\n  const urlprefix = 'https://bsky.app/';\n  if (handle && handle.lastIndexOf(urlprefix, 0) === 0) {\n    const postURL = breakPostURL(handle);\n    if (postURL && postURL.shortDID)\n      return postURL.shortDID;\n  }\n\n  if (handle && handle.lastIndexOf('at:', 0) === 0) {\n    const feedUri = breakFeedUri(handle);\n    if (feedUri && feedUri.shortDID)\n      return feedUri.shortDID;\n\n    if (handle && handle.lastIndexOf('at://', 0) === 0) handle = handle.slice(5);\n    else handle = handle.slice(3);\n  }\n\n  return handle || undefined;\n}\n\n/** @param {string | undefined | null} pdc */\nexport function shortenPDC(pdc) {\n  if (!pdc) return undefined;\n\n  pdc = pdc.trim().toLowerCase();\n\n  if (pdc === 'https://bsky.social') return '.s';\n  else if (pdc === 'https://bsky.network') return '.n';\n  else if (pdc === 'https://bsky.app') return '.a';\n\n  // https://morel.us-east.host.bsky.network\n  return pdc.replace(/^https:\\/\\//, '').replace(/host\\.bsky\\.network$/, '');\n}\n\nexport function unwrapShortPDC(shortPDC) {\n  if (!shortPDC) return undefined;\n\n  if (shortPDC === '.s') return 'https://bsky.social';\n  else if (shortPDC === '.n') return 'https://bsky.network';\n  else if (shortPDC === '.a') return 'https://bsky.app';\n\n  return 'https://' + shortPDC + 'host.bsky.network';\n}\n\n/**\n * dd+hh:mm:ss like 30+23:59:59\n * @param {string | null | undefined} dtOffsetStr\n */\nexport function parseTimestampOffset(dtOffsetStr) {\n\n  if (!dtOffsetStr) return undefined;\n\n  let offset = 0;\n  let lead = 0;\n  const plusPos = dtOffsetStr.indexOf('+');\n  if (plusPos >= 0) {\n    offset = Number(dtOffsetStr.substring(0, plusPos)) * 24 * 60 * 60 * 1000;\n    lead = plusPos + 1;\n  }\n\n  const secondsColonPos = dtOffsetStr.lastIndexOf(':');\n  if (secondsColonPos < 0) {\n    offset += Number(dtOffsetStr.substring(lead)) * 1000;\n  } else {\n    offset += Number(dtOffsetStr.substring(secondsColonPos + 1)) * 1000;\n\n    const minutesColonPos = dtOffsetStr.lastIndexOf(':', secondsColonPos - 1);\n    if (minutesColonPos < 0) {\n      offset += Number(dtOffsetStr.substring(lead, secondsColonPos)) * 60 * 1000;\n    } else {\n      offset += Number(dtOffsetStr.substring(minutesColonPos + 1, secondsColonPos)) * 60 * 1000;\n      offset += Number(dtOffsetStr.substring(lead, minutesColonPos)) * 60 * 60 * 1000;\n    }\n  }\n\n  return offset;\n}\n\n/** dd+hh:mm:ss */\nexport function timestampOffsetToString(offset) {\n  offset = Math.floor(offset / 1000);\n  const seconds = offset % 60;\n  offset = (offset - seconds) / 60;\n  const minutes = offset % 60;\n  offset = (offset - minutes) / 60;\n  const hours = offset % 24;\n  const days = (offset - hours) / 24;\n\n  let str = (100 + seconds).toString().slice(1);\n  if (days + hours + minutes) {\n    str = (100 + minutes).toString().slice(1) + ':' + str;\n    if (days + hours) {\n      str = hours.toString() + ':' + str;\n      if (days) {\n        str = days + '+' + str;\n      }\n    }\n  }\n\n  // no need for leading zero\n  if (str.lastIndexOf('0', 0) === 0) str = str.slice(1);\n\n  return str;\n}\n\n/**\n* @param {string | null | undefined} url\n*/\nexport function breakPostURL(url) {\n  if (!url) return;\n  const match = _breakPostURL_Regex.exec(url);\n  if (!match) return;\n  return { shortDID: match[1], postID: match[2] };\n}\nconst _breakPostURL_Regex = /^http[s]?\\:\\/\\/bsky\\.app\\/profile\\/([a-z0-9\\.\\:]+)\\/post\\/([a-z0-9]+)$/;\n\n/**\n* @param {string | null | undefined} uri\n*/\nexport function breakFeedUri(uri) {\n  if (!uri) return;\n  const match = _breakFeedUri_Regex.exec(uri);\n  if (!match || !match[3]) return;\n  return { shortDID: match[2], postID: match[3] };\n}\nconst _breakFeedUri_Regex = /^at\\:\\/\\/(did:plc:)?([a-z0-9]+)\\/[a-z\\.]+\\/?(.*)?$/;\n", "// @ts-check\n\nimport { streamBuffer } from '../src/api/akpa';\nimport { retryFetch } from '../src/api/retry-fetch';\nimport { shortenDID, shortenHandle, shortenPDC } from './shorten';\n\n/**\n * @typedef {{\n *  fetch?: typeof retryFetch\n * }} Overrides\n */\n\n/**\n * @typedef {{\n *  did: string,\n *  cid: string,\n *  nullified: boolean,\n *  createdAt: string,\n *  operation: {\n *    type: 'create' | 'plc_operation',\n *    sig: string,\n *    alsoKnownAs?: string[],\n *    handle?: string,\n *    prev: string | null,\n *    service?: string,\n *    services?: {\n *      atproto_pds?: {\n *        type: 'AtprotoPersonalDataServer',\n *        endpoint: string\n *      }\n *    },\n *    rotationKeys: any[],\n *    verificationMethods: {}\n *  }\n * }} PLCDirectoryEntry\n */\n\nconst FETCH_AHEAD_MSEC_MAX = 10000;\nconst FETCH_AHEAD_COUNT_MAX = 10000\n\n/**\n * @param {string | Date | number | null} [since]\n * @param {Overrides} [overrides]\n * @returns {AsyncGenerator<{ entries: PLCDirectoryEntry[], overlap: number }>}\n */\nexport function plcDirectory(since, overrides) {\n  const useFetch = overrides?.fetch || fetch;\n  return streamBuffer(async stream => {\n    const EXPORT_URL = 'https://plc.directory/export';\n\n    let sinceTime;\n    if (since) {\n      if (typeof since === 'string') {\n        since = new Date(since);\n      } else if (typeof since === 'number') {\n        since = new Date(since);\n      }\n\n      if (Number.isFinite(since.getTime()))\n        sinceTime = since.toISOString();\n    }\n\n    const lastChunkLines = new Set();\n    let lastWaitedForConsumptionAt = Date.now();\n    let collectedEntriesSinceLastWaitedForConsumption = 0;\n\n    while (true) {\n      const nextChunkRe = await useFetch(\n        EXPORT_URL + (sinceTime ? '?after=' + sinceTime : '')\n      );\n\n      if (stream.isEnded) return;\n\n      const nextChunkText = await nextChunkRe.text();\n\n      const chunkLines = nextChunkText.split('\\n');\n      let overlap = 0;\n      const nextChunkEnitres = [];\n      for (const line of chunkLines) {\n        if (lastChunkLines.has(line)) {\n          overlap++;\n          continue;\n        }\n\n        if (!line) continue;\n        nextChunkEnitres.push(JSON.parse(line));\n      }\n\n      if (nextChunkEnitres.length) {\n        lastChunkLines.clear();\n        for (const line of chunkLines) {\n          lastChunkLines.add(line);\n        }\n\n        collectedEntriesSinceLastWaitedForConsumption += nextChunkEnitres.length;\n      }\n\n      const waitForConsumption = stream.yield(\n        { entries: nextChunkEnitres, overlap },\n        (buffer, item) => {\n          if (!buffer) return item;\n          buffer.entries = buffer.entries.concat(item.entries);\n          buffer.overlap += item.overlap;\n          return buffer;\n        }\n      );\n      if (stream.isEnded) return;\n\n      const shouldWaitForConsumption =\n        collectedEntriesSinceLastWaitedForConsumption > FETCH_AHEAD_COUNT_MAX ||\n        Date.now() - lastWaitedForConsumptionAt > FETCH_AHEAD_MSEC_MAX ||\n        !nextChunkEnitres.length;\n      \n      if (shouldWaitForConsumption) {\n        await waitForConsumption;\n        if (stream.isEnded) return;\n      }\n\n      /** @type {Date | undefined} */\n      let nextSinceTime;\n      // iterate backwards to find timestamp just before latest\n      for (let i = 0; i < nextChunkEnitres.length; i++) {\n        const entry = nextChunkEnitres[nextChunkEnitres.length - i - 1];\n        if (entry.createdAt) {\n          const timestamp = new Date(entry.createdAt);\n          if (!nextSinceTime && timestamp.getTime()) {\n            nextSinceTime = timestamp;\n          } else if (nextSinceTime && timestamp.getTime() &&\n            timestamp.getTime() < nextSinceTime.getTime()) {\n            sinceTime = timestamp.toISOString();\n            break;\n          }\n        }\n      }\n    }\n\n  });\n}\n\n/**\n * @typedef {{\n *  timestamp: number,\n *  shortDID: string,\n *  shortHandle?: string,\n *  shortPDC?: string;\n * }} PLCDirectoryEntryCompact\n */\n\n/**\n * @param {string | Date | number | null} [since]\n * @param {Overrides} [overrides]\n * @returns {AsyncGenerator<{ entries: PLCDirectoryEntryCompact[] }>}\n */\nexport async function* plcDirectoryCompact(since, overrides) {\n  const iteration = plcDirectory(since, overrides);\n  for await (const chunk of iteration) {\n    const compactEntries = [];\n    for (const entry of chunk.entries) {\n      const timestamp = new Date(entry.createdAt).getTime();\n      const compact = {\n        timestamp,\n        shortDID: shortenDID(entry.did),\n        shortHandle: shortenHandle(\n          entry.operation.alsoKnownAs?.[0] || entry.operation.handle),\n        shortPDC: shortenPDC(\n          entry.operation.services?.atproto_pds?.endpoint ||\n          entry.operation.service)\n      };\n      compactEntries.push(compact);\n    }\n\n    yield { entries: compactEntries };\n  }\n}", "// @ts-check\n/// <reference path=\"./types.d.ts\" />\n\nimport { parseTimestampOffset } from '../../../lib/shorten';\n\n/** @extends {Map<string, RegistrationHistory>} */\nclass MapExtended extends Map {\n  file = '';\n  next = undefined;\n  earliestRegistration = undefined;\n  latestRegistration = undefined;\n  latestAction = undefined;\n}\n\n/**\n * @param {string} file\n * @param {string} jsonText\n * @returns {RegistrationStore}\n */\nexport function parseRegistrationStore(file, jsonText) {\n  const bucketMap = JSON.parse(jsonText);\n\n  const store = createEmptyStore(file);\n\n  let carryTimestamp = 0;\n  for (const shortDID in bucketMap) {\n    if (shortDID === 'next') store.next = bucketMap.next;\n\n    /** @type {RegistrationHistory['updates']} */\n    const registrationHistory = bucketMap[shortDID];\n    for (const entry in registrationHistory) {\n      if (!carryTimestamp) carryTimestamp = new Date(entry).getTime();\n      else carryTimestamp += parseTimestampOffset(entry) || 0;\n      break;\n    }\n\n    const registrationEntry = {\n      created: carryTimestamp,\n      updates: registrationHistory\n    };\n    updateRanges(carryTimestamp, store);\n    updateLatestCreation(carryTimestamp, store);\n\n    let carryHistoryOffset = 0;\n    let firstHistoryEntry = true;\n    for (const dateOrTimestamp in registrationHistory) {\n      if (firstHistoryEntry) {\n        firstHistoryEntry = false;\n        continue;\n      }\n\n      carryHistoryOffset += parseTimestampOffset(dateOrTimestamp) || 0;\n      updateRanges(carryTimestamp + carryHistoryOffset, store);\n    }\n\n    store.set(shortDID, registrationEntry);\n  }\n\n  return store;\n}\n\n/**\n * @param {number | undefined} prevTimestamp\n * @param {number} timestamp\n */\nexport function deriveStoreFilenameFromTimestamp(prevTimestamp, timestamp) {\n  const dt = new Date(timestamp);\n  const dtPrev = prevTimestamp ? new Date(prevTimestamp) : undefined;\n\n  // 2024-02/4\n  let filename =\n    dt.getUTCFullYear() + '-' +\n    (101 + dt.getUTCMonth()).toString().slice(1) + '/' +\n    dt.getUTCDate();\n\n  if (dt.getUTCFullYear() === dtPrev?.getUTCFullYear() &&\n    dt.getUTCMonth() === dtPrev?.getUTCMonth() &&\n    dt.getUTCDate() === dtPrev?.getUTCDate()) {\n\n    // 2024-02/4-634\n    filename +=\n      '-' + dt.getUTCHours().toString().slice(1) +\n      (101 + dt.getUTCMinutes()).toString().slice(1);\n    \n    if (dt.getUTCHours() === dtPrev.getUTCHours() &&\n      dt.getUTCMinutes() === dtPrev.getUTCMinutes()) {\n      // 2024-02/4-634-12\n      filename +=\n        '-' + (101 + dt.getUTCSeconds()).toString().slice(1);\n\n      if (dt.getUTCSeconds() === dtPrev.getUTCSeconds()) {\n        filename +=\n          '_' + (1001 + dt.getUTCMilliseconds()).toString().slice(1);\n        \n        if (dt.getUTCMilliseconds() === dtPrev.getUTCMilliseconds()) {\n          filename +=\n            '-' + Math.random().toString(36).slice(2, 4);\n        }\n      }\n    }\n  }\n\n  return filename;\n}\n\n/** @param {string} file */\nexport function createEmptyStore(file) {\n  const store = /** @type {RegistrationStore} */(\n    new MapExtended());\n  store.file = file;\n  return store;\n}\n\n/**\n * @param {number | undefined} timestamp\n * @param {RegistrationStore} store\n */\nfunction updateRanges(timestamp, store) {\n  if (!timestamp) return;\n  if (!store.earliestRegistration || timestamp < store.earliestRegistration) store.earliestRegistration = timestamp;\n  if (!store.latestAction || timestamp > store.latestAction) store.latestAction = timestamp;\n}\n\n/**\n * @param {number | undefined} createdTimestamp\n * @param {RegistrationStore} store\n */\nfunction updateLatestCreation(createdTimestamp, store) {\n  if (!createdTimestamp) return;\n  if (!store.latestRegistration || createdTimestamp > store.latestRegistration) store.latestRegistration = createdTimestamp;\n}\n\n\n/**\n * @param {RegistrationStore} store\n * @returns {string}\n */\nexport function stringifyRegistrationStore(store) {\n  let jsonText = '{\\n';\n  let first = true;\n  for (const shortDID of store.keys()) {\n    const registrationEntry = /** @type {RegistrationHistory} */(store.get(shortDID));\n    jsonText += first ?\n      ',\\n\"' + shortDID + '\":' + JSON.stringify(registrationEntry.updates) + '\\n' :\n      '\"' + shortDID + '\":' + JSON.stringify(registrationEntry.updates) + '\\n';\n  }\n  if (store.next) jsonText += ',\\n\"next\":' + JSON.stringify(store.next) + '\\n';\n  jsonText += '}';\n  return jsonText;\n}", "// @ts-check\n/// <reference path=\"./types.d.ts\" />\n\nimport { plcDirectoryCompact } from '../../../lib/plc-directory';\nimport { parseTimestampOffset, timestampOffsetToString } from '../../../lib/shorten';\nimport { retryFetch } from '../retry-fetch';\nimport { createEmptyStore, deriveStoreFilenameFromTimestamp, parseRegistrationStore } from './persistence';\n\n/**\n * @typedef {{\n *  read(path: string): Promise<string | undefined>,\n *  fetch?: typeof fetch\n * }} IndexingRunParams\n */\n\n/**\n * @typedef {{\n *  stores: RegistrationStore[],\n *  affectedStores?: RegistrationStore[],\n *  affectedShortDIDs?: string[],\n *  addedShortDIDs?: string[],\n *  earliestRegistration?: number,\n *  latestRegistration?: number,\n *  latestAction?: number,\n *  loadedAllStores?: boolean\n * }} IndexingRunProgress\n */\n\nconst MAX_STORE_SIZE = 50_000;\n\n/**\n * @param {IndexingRunParams} params\n * @returns {AsyncIterable<IndexingRunProgress>}\n */\nexport async function* indexingRun({ read, fetch: useFetch }) {\n  /** @type {RegistrationStore[]} */\n  let stores = [];\n\n  /** @type {Map<string, RegistrationStore>} */\n  const storeByShortDID = new Map();\n  let maxDate = new Date('2022-11-01').getTime();\n  for await (const progress of loadAllStores({ read })) {\n    stores = progress.stores;\n\n    if (progress.latestAction) maxDate = progress.latestAction;\n    for (const store of stores) {\n      for (const shortDID of store.keys()) {\n        storeByShortDID.set(shortDID, store);\n      }\n    }\n    yield progress;\n  }\n\n  if (!useFetch) useFetch = (req, opts) => retryFetch(req, { ...opts, nocorsproxy: true });\n\n  for await (const progress of pullDirectory({ stores, storeByShortDID, startDate: maxDate, fetch: useFetch })) {\n    stores = progress.stores;\n    yield progress;\n  }\n\n}\n\n/**\n * @param {{\n *  stores: RegistrationStore[],\n *  storeByShortDID: Map<string, RegistrationStore>,\n *  startDate: number,\n *  fetch?: typeof fetch\n * }} _\n */\nasync function* pullDirectory({ stores, storeByShortDID, startDate, fetch }) {\n\n  for await (const chunk of plcDirectoryCompact(startDate, { fetch })) {\n    const affectedShortDIDs = new Set();\n    const affectedStores = new Set();\n\n    /** @type {number | undefined} */\n    let earliestRegistration;\n    /** @type {number | undefined} */\n    let latestRegistration;\n    /** @type {number | undefined} */\n    let latestAction;\n\n    /** @type {string[]} */\n    let addedShortDIDs = [];\n\n    for (const entry of chunk.entries) {\n      affectedShortDIDs.add(entry.shortDID);\n\n      /** @type {HistoryChange} */\n      const historyChange = {\n        h: clampShortHandle(entry.shortHandle),\n        p: entry.shortPDC\n      };\n\n      const existingStore = storeByShortDID.get(entry.shortDID);\n      if (existingStore) {\n        affectedStores.add(existingStore);\n        // update history for the already registered shortDID\n        const existingHistory = /** @type {RegistrationHistory} */(\n          existingStore.get(entry.shortDID));\n        addHistoryToExistingShortDID(existingHistory, historyChange, entry);\n        if (!latestAction || entry.timestamp > latestAction)\n          latestAction = entry.timestamp;\n\n      } else {\n        /** @type {RegistrationHistory} */\n        const history = {\n          created: entry.timestamp,\n          updates: {\n            [new Date(entry.timestamp).toISOString()]: historyChange\n          }\n        };\n\n        addedShortDIDs.push(entry.shortDID);\n        if (!earliestRegistration || entry.timestamp < earliestRegistration)\n          earliestRegistration = entry.timestamp;\n        if (!latestRegistration || entry.timestamp > latestRegistration)\n          latestRegistration = entry.timestamp;\n        if (!latestAction || entry.timestamp > latestAction)\n          latestAction = entry.timestamp;\n\n        const { store, insertStoreAt } = findStoreToAddTimestamp(stores, entry.timestamp);\n        if (store) {\n          affectedStores.add(store);\n          // insert into the store\n          if (!store.latestRegistration || entry.timestamp >= store.latestRegistration) {\n            // at the end\n            addNewShortDIDToExistingStoreEnd(store, history, entry);\n          } else {\n            // in the middle: recreate the store\n            addNewShortDIDToExistingStoreMiddle(store, history, entry);\n          }\n        } else {\n          // add a new store\n          const { newStore, prevStore } = createNewStoreAddShortDID(stores, insertStoreAt, history, entry);\n\n          storeByShortDID.set(entry.shortDID, newStore);\n          stores.push(newStore);\n\n          affectedStores.add(newStore);\n          if (prevStore) affectedStores.add(prevStore);\n        }\n      }\n   }\n\n    yield {\n      stores: stores,\n      loadedAllStores: true,\n      addedShortDIDs,\n      affectedShortDIDs: Array.from(affectedShortDIDs),\n      affectedStores: Array.from(affectedStores),\n      earliestRegistration,\n      latestRegistration,\n      latestAction\n    };\n  }\n}\n\n/**\n * @param {RegistrationHistory} history\n * @param {HistoryChange} historyChange\n * @param {import('../../../lib/plc-directory').PLCDirectoryEntryCompact} entry\n */\nfunction addHistoryToExistingShortDID(history, historyChange, entry) {\n  let firstHistoryEntry = true;\n  let carryTimestamp = history.created;\n  for (const dateOrTimestamp in history.updates) {\n    let carryTimestampNext =\n      firstHistoryEntry ? carryTimestamp :\n        carryTimestamp = parseTimestampOffset(dateOrTimestamp) || 0;\n\n    if (firstHistoryEntry) firstHistoryEntry = false;\n\n    if (carryTimestamp > entry.timestamp) {\n      console.warn(\n        'Past history update? ',\n        {\n          entry,\n          history,\n          carryTimestamp: new Date(carryTimestamp),\n          carryTimestampNext: new Date(carryTimestampNext)\n        }\n      );\n\n      /** @type {RegistrationHistory['updates']} */\n      const newUpdates = {};\n      for (const prevDateOrTimestamp in history.updates) {\n        if (prevDateOrTimestamp === dateOrTimestamp)\n          newUpdates[timestampOffsetToString(entry.timestamp)] = historyChange;\n        newUpdates[prevDateOrTimestamp] = history.updates[prevDateOrTimestamp];\n      }\n\n      return;\n    }\n\n    carryTimestamp = carryTimestampNext;\n  }\n\n  history.updates[timestampOffsetToString(entry.timestamp)] = historyChange;\n}\n\n/**\n * @param {RegistrationStore} store\n * @param {RegistrationHistory} history\n * @param {import('../../../lib/plc-directory').PLCDirectoryEntryCompact} entry\n */\nfunction addNewShortDIDToExistingStoreEnd(store, history, entry) {\n  store.set(entry.shortDID, history);\n  if (!store.earliestRegistration) store.earliestRegistration = entry.timestamp;\n  store.latestRegistration = entry.timestamp;\n  if (!store.latestAction || entry.timestamp > store.latestAction)\n    store.latestAction = entry.timestamp;\n}\n\n/**\n * @param {RegistrationStore} store\n * @param {RegistrationHistory} history\n * @param {import('../../../lib/plc-directory').PLCDirectoryEntryCompact} entry\n */\nfunction addNewShortDIDToExistingStoreMiddle(store, history, entry) {\n  const entries = Array.from(store.entries());\n  store.clear();\n  for (const [existingShortDID, existingHistory] of entries) {\n    if (entry.timestamp >= existingHistory.created)\n      store.set(entry.shortDID, history);\n    store.set(existingShortDID, existingHistory);\n  }\n  if (!store.has(entry.shortDID)) {\n    console.warn(\n      'This shortDID should not appear at the end according to latestCreation ' +\n      new Date(/** @type {number} */(store.latestRegistration)) +\n      ' being after' + new Date(history.created),\n      { entry, store });\n    store.set(entry.shortDID, history);\n  }\n  if (!store.latestAction || entry.timestamp > store.latestAction)\n    store.latestAction = entry.timestamp;\n}\n\n/**\n * @param {RegistrationStore[]} stores\n * @param {number} insertStoreAt\n * @param {RegistrationHistory} history\n * @param {import('../../../lib/plc-directory').PLCDirectoryEntryCompact} entry\n */\nfunction createNewStoreAddShortDID(stores, insertStoreAt, history, entry) {\n  const prevStore = stores[insertStoreAt - 1];\n\n  const file = deriveStoreFilenameFromTimestamp(\n    prevStore?.values().next().value?.created,\n    entry.timestamp);\n\n  const newStore = createEmptyStore(file);\n  newStore.next = prevStore?.next;\n  if (prevStore) prevStore.next = file;\n\n  newStore.latestAction =\n    newStore.latestRegistration =\n    newStore.earliestRegistration =\n    entry.timestamp;\n\n  newStore.set(entry.shortDID, history);\n  return { newStore, prevStore };\n}\n\n/**\n * @param {RegistrationStore[]} stores\n * @param {number} timestamp\n * @returns {{ store: RegistrationStore, insertStoreAt?: undefined } |\n *  {store?: undefined, insertStoreAt: number }}\n */\nfunction findStoreToAddTimestamp(stores, timestamp) {\n  if (!stores?.length) return { insertStoreAt: 0 };\n\n  const latestStore = stores[stores.length - 1];\n  if (!latestStore.earliestRegistration || timestamp >= latestStore.earliestRegistration ||\n    stores.length === 1) {\n    if (latestStore.size < MAX_STORE_SIZE) return { store: latestStore };\n    else return { insertStoreAt: stores.length };\n  }\n\n  // timestamp falls before the latestStore, probably need to insert in the past history\n\n  const monthStartTimestamp = getMonthStart(timestamp);\n\n  for (let storeIndex = stores.length - 1; storeIndex > 0; storeIndex--) { // if storeIndex hit zero, that's our store\n    const tryStore = stores[storeIndex];\n    if (timestamp < (tryStore.earliestRegistration || 0)) continue;\n\n    // we found the point!\n    // is this within the store's range?\n\n    if (timestamp < (tryStore.latestAction || 0)) return { store: tryStore };\n\n    const nextStore = stores[storeIndex + 1];\n    const monthStartNext = getMonthStart(nextStore.earliestRegistration || 0);\n\n    if (monthStartTimestamp === monthStartNext) {\n      // nextStore is in the right range\n      // but do we have space?\n      // (allow expanding stores in the middle a little bit)\n      if (nextStore.size < MAX_STORE_SIZE * 1.2) return { store: nextStore };\n      else return { insertStoreAt: storeIndex + 1 };\n    } else {\n      // neither, insert in between\n      return { insertStoreAt: storeIndex + 1 };\n    }\n  }\n\n  return { insertStoreAt: 0 };\n}\n\nconst dt = new Date();\nfunction getMonthStart(timestamp) {\n  dt.setTime(timestamp);\n  dt.setUTCDate(1);\n  dt.setUTCHours(0);\n  dt.setUTCMinutes(0);\n  dt.setUTCSeconds(0);\n  dt.setUTCMilliseconds(0);\n  return dt.getTime();\n}\n\nfunction clampShortHandle(shortHandle) {\n  let clampShortHandle = shortHandle;\n  if (clampShortHandle && clampShortHandle.length > 30)\n    clampShortHandle = clampShortHandle.slice(0, 25) + '...' + clampShortHandle.slice(-2);\n  return clampShortHandle;\n}\n\n/**\n * @param {IndexingRunParams} params\n * @returns {AsyncIterable<IndexingRunProgress>}\n */\nasync function* loadAllStores({ read }) {\n  const inceptionText = await read('inception.json');\n\n  /** @type {string | undefined} */\n  let next = inceptionText ? JSON.parse(inceptionText).next : undefined;\n  if (!next) return yield { stores: [], loadedAllStores: true };\n\n  /** @type {RegistrationStore[]} */\n  const stores = [];\n  /** @type {number | undefined} */\n  let earliestRegistration;\n  /** @type {number | undefined} */\n  let latestRegistration;\n  /** @type {number | undefined} */\n  let latestAction;\n\n\n  while (next) {\n    const storeText = await read(next);\n    if (!storeText) break;\n\n    const store = parseRegistrationStore(next, storeText);\n    const affectedShortDIDs = Array.from(store.keys());\n    if (!earliestRegistration || store.earliestRegistration && store.earliestRegistration < earliestRegistration)\n      earliestRegistration = store.earliestRegistration;\n    if (!latestRegistration || store.latestRegistration && store.latestRegistration > latestRegistration)\n      latestRegistration = store.latestRegistration;\n    if (!latestAction || store.latestAction && store.latestAction > latestAction)\n      latestAction = store.latestAction;\n\n    stores.push(store);\n\n    if (!store.next) {\n      yield {\n        loadedAllStores: true,\n        stores, // last yield, return raw underlying array\n        earliestRegistration,\n        latestRegistration,\n        latestAction,\n        affectedStores: [store],\n        affectedShortDIDs,\n        addedShortDIDs: affectedShortDIDs\n      };\n      return;\n    }\n\n    next = store.next;\n    yield {\n      loadedAllStores: false,\n      stores: stores.slice(),\n      earliestRegistration,\n      latestRegistration,\n      latestAction,\n      affectedStores: [store],\n      affectedShortDIDs\n    };\n  }\n\n  yield {\n    loadedAllStores: true,\n    stores, // last yield, return raw underlying array\n    earliestRegistration,\n    latestRegistration,\n    latestAction\n    // no affectedStores or affectedShortDIDs - last read was empty\n  };\n}", "// @ts-check\n\nconst alertIfRecent = new Date(2023, 11, 1);\n\nexport async function pullPLCDirectoryCompact() {\n  const fs = require('fs');\n  const path = require('path');\n\n  const { indexingRun } = require('./indexing-run');\n\n  console.log('PLC directory CACHE');\n\n  const directoryPath = path.resolve(__dirname, 'src/api/indexing/repos/directory');\n  const run = indexingRun({\n    read: (localPath) => new Promise((resolve, reject) => {\n      const filePath = path.resolve(directoryPath, localPath.replace(/^\\//, ''));\n      fs.readFile(filePath, 'utf8', (err, data) => {\n        if (err) reject(err);\n        else resolve(data);\n      });\n    })\n  });\n\n  for await (const progress of run) {\n  }\n}\n\n", "// @ts-check\n/// <reference path=\"./types.d.ts\" />\n\nexport { indexingRun } from './indexing-run.js';", "// @ts-check\n\nimport { pullPLCDirectoryCompact } from './api/indexing/pull-plc-directory';\nimport { indexingRun } from './api/indexing';\n\nasync function pullPLCDirectoryLocal() {\n  console.log('Pulling PLC directory...');\n\n  // TODO: load existing directory from disk\n\n  const run = indexingRun({\n    read: async (localPath) => {\n      try {\n        const re = await fetch(\n          location.protocol + '//' +\n          'history.dids.colds.ky' + '/' + localPath.replace(/^\\//, ''));\n        if (re.status !== 200) return;\n        const text = await re.text();\n        return text;\n      } catch (fetchError) {\n        console.warn(localPath, fetchError);\n      }\n    }\n  });\n\n  for await (const progress of run) {\n    console.log(progress);\n  }\n}\n\nif (typeof require === 'function' && typeof process !== 'undefined' && typeof process.exit === 'function') {\n  if (require.main === module) pullPLCDirectoryCompact();\n  else module.exports = { indexingRun }\n} else {\n  pullPLCDirectoryLocal();\n}\n"],
  "mappings": "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",
  "names": ["dt", "dt", "iter", "more", "temp", "error", "fetch", "clampShortHandle", "indexingRun"]
}

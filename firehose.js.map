{"version":3,"file":"firehose.js","sources":["node_modules/@atcute/uint8array/dist/index.js","node_modules/@atcute/multibase/dist/utils.js","node_modules/@atcute/multibase/dist/bases/base64-web.js","node_modules/@atcute/multibase/dist/bases/base32.js","node_modules/@atcute/varint/dist/index.js","node_modules/@atcute/cid/dist/codec.js","node_modules/@atcute/cid/dist/cid-link.js","node_modules/@atcute/cbor/dist/bytes.js","node_modules/@atcute/cbor/dist/decode.js","node_modules/@atcute/car/dist/utilities/sync-byte-reader.js","node_modules/@atcute/car/dist/utilities/car.js","node_modules/@atcute/car/dist/utilities/sync-car-reader.js","node_modules/@atcute/car/dist/reader.js","node_modules/bski/firehose.js","package/firehose.js"],"sourcesContent":["const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nconst subtle = crypto.subtle;\n/**\n * creates an Uint8Array of the requested size, with the contents zeroed\n */\nexport const alloc = (size) => {\n    return new Uint8Array(size);\n};\n/**\n * creates an Uint8Array of the requested size, where the contents may not be\n * zeroed out. only use if you're certain that the contents will be overwritten\n */\nexport const allocUnsafe = alloc;\n/**\n * compares two Uint8Array buffers\n */\nexport const compare = (a, b) => {\n    const alen = a.length;\n    const blen = b.length;\n    if (alen > blen) {\n        return 1;\n    }\n    if (alen < blen) {\n        return -1;\n    }\n    for (let i = 0; i < alen; i++) {\n        const ax = a[i];\n        const bx = b[i];\n        if (ax < bx) {\n            return -1;\n        }\n        if (ax > bx) {\n            return 1;\n        }\n    }\n    return 0;\n};\n/**\n * checks if the two Uint8Array buffers are equal\n */\nexport const equals = (a, b) => {\n    if (a === b) {\n        return true;\n    }\n    let len;\n    if ((len = a.length) === b.length) {\n        while (len--) {\n            if (a[len] !== b[len]) {\n                return false;\n            }\n        }\n    }\n    return len === -1;\n};\n/**\n * checks if the two Uint8Array buffers are equal, timing-safe version\n */\nexport const timingSafeEquals = (a, b) => {\n    let len;\n    let out = 0;\n    if ((len = a.length) === b.length) {\n        while (len--) {\n            out |= a[len] ^ b[len];\n        }\n    }\n    return len === -1 && out === 0;\n};\n/**\n * concatenates multiple Uint8Array buffers into one\n */\nexport const concat = (arrays, size) => {\n    let written = 0;\n    let len = arrays.length;\n    let idx;\n    if (size === undefined) {\n        for (idx = size = 0; idx < len; idx++) {\n            const chunk = arrays[idx];\n            size += chunk.length;\n        }\n    }\n    const buffer = new Uint8Array(size);\n    for (idx = 0; idx < len; idx++) {\n        const chunk = arrays[idx];\n        buffer.set(chunk, written);\n        written += chunk.length;\n    }\n    return buffer;\n};\n/**\n * encodes a UTF-8 string into the buffer\n */\nexport const encodeUtf8Into = (to, str, offset, length) => {\n    let buffer;\n    if (offset === undefined) {\n        buffer = to;\n    }\n    else if (length === undefined) {\n        buffer = to.subarray(offset);\n    }\n    else {\n        buffer = to.subarray(offset, offset + length);\n    }\n    const result = textEncoder.encodeInto(str, buffer);\n    return result.written;\n};\n/**\n * decodes a UTF-8 string from a buffer\n */\nexport const decodeUtf8From = (from, offset, length) => {\n    let buffer;\n    if (offset === undefined) {\n        buffer = from;\n    }\n    else if (length === undefined) {\n        buffer = from.subarray(offset);\n    }\n    else {\n        buffer = from.subarray(offset, offset + length);\n    }\n    const result = textDecoder.decode(buffer);\n    return result;\n};\n/**\n * get a SHA-256 digest of this buffer\n */\nexport const toSha256 = async (buffer) => {\n    return new Uint8Array(await subtle.digest('SHA-256', buffer));\n};\n//# sourceMappingURL=index.js.map","import { alloc, allocUnsafe } from '@atcute/uint8array';\nexport const createRfc4648Encode = (alphabet, bitsPerChar, pad) => {\n    return (bytes) => {\n        const mask = (1 << bitsPerChar) - 1;\n        let str = '';\n        let bits = 0; // Number of bits currently in the buffer\n        let buffer = 0; // Bits waiting to be written out, MSB first\n        for (let i = 0; i < bytes.length; ++i) {\n            // Slurp data into the buffer:\n            buffer = (buffer << 8) | bytes[i];\n            bits += 8;\n            // Write out as much as we can:\n            while (bits > bitsPerChar) {\n                bits -= bitsPerChar;\n                str += alphabet[mask & (buffer >> bits)];\n            }\n        }\n        // Partial character:\n        if (bits !== 0) {\n            str += alphabet[mask & (buffer << (bitsPerChar - bits))];\n        }\n        // Add padding characters until we hit a byte boundary:\n        if (pad) {\n            while (((str.length * bitsPerChar) & 7) !== 0) {\n                str += '=';\n            }\n        }\n        return str;\n    };\n};\nexport const createRfc4648Decode = (alphabet, bitsPerChar, pad) => {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    return (str) => {\n        // Count the padding bytes:\n        let end = str.length;\n        while (pad && str[end - 1] === '=') {\n            --end;\n        }\n        // Allocate the output:\n        const bytes = allocUnsafe(((end * bitsPerChar) / 8) | 0);\n        // Parse the data:\n        let bits = 0; // Number of bits currently in the buffer\n        let buffer = 0; // Bits waiting to be written out, MSB first\n        let written = 0; // Next byte to write\n        for (let i = 0; i < end; ++i) {\n            // Read one character from the string:\n            const value = codes[str[i]];\n            if (value === undefined) {\n                throw new SyntaxError(`invalid base string`);\n            }\n            // Append the bits to the buffer:\n            buffer = (buffer << bitsPerChar) | value;\n            bits += bitsPerChar;\n            // Write out some bits if the buffer has a byte's worth:\n            if (bits >= 8) {\n                bits -= 8;\n                bytes[written++] = 0xff & (buffer >> bits);\n            }\n        }\n        // Verify that we have received just enough bits:\n        if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n            throw new SyntaxError('unexpected end of data');\n        }\n        return bytes;\n    };\n};\nexport const createBtcBaseEncode = (alphabet) => {\n    if (alphabet.length >= 255) {\n        throw new RangeError(`alphabet too long`);\n    }\n    const BASE = alphabet.length;\n    const LEADER = alphabet.charAt(0);\n    const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    return (source) => {\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        let zeroes = 0;\n        let length = 0;\n        let pbegin = 0;\n        const pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        const b58 = alloc(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            let carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            let i = 0;\n            for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        let it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        let str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += alphabet.charAt(b58[it2]);\n        }\n        return str;\n    };\n};\nexport const createBtcBaseDecode = (alphabet) => {\n    if (alphabet.length >= 255) {\n        throw new RangeError(`alphabet too long`);\n    }\n    const BASE_MAP = allocUnsafe(256).fill(255);\n    for (let i = 0; i < alphabet.length; i++) {\n        const xc = alphabet.charCodeAt(i);\n        if (BASE_MAP[xc] !== 255) {\n            throw new RangeError(`${alphabet[i]} is ambiguous`);\n        }\n        BASE_MAP[xc] = i;\n    }\n    const BASE = alphabet.length;\n    const LEADER = alphabet.charAt(0);\n    const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    return (source) => {\n        if (source.length === 0) {\n            return allocUnsafe(0);\n        }\n        // Skip and count leading '1's.\n        let psz = 0;\n        let zeroes = 0;\n        let length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        const size = ((source.length - psz) * FACTOR + 1) >>> 0; // log(58) / log(256), rounded up.\n        const b256 = alloc(size);\n        // Process the characters.\n        while (psz < source.length) {\n            // Decode character\n            let carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                throw new Error(`invalid string`);\n            }\n            let i = 0;\n            for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        let it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        if (it4 === zeroes) {\n            return b256;\n        }\n        const vch = allocUnsafe(zeroes + (size - it4));\n        vch.fill(0, 0, zeroes);\n        vch.set(b256.subarray(it4), zeroes);\n        return vch;\n    };\n};\n//# sourceMappingURL=utils.js.map","import { createRfc4648Decode, createRfc4648Encode } from '../utils.js';\nconst HAS_UINT8_BASE64_SUPPORT = 'fromBase64' in Uint8Array;\nconst BASE64_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst BASE64URL_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n// seems to be faster if we just check for the specific characters that are forbidden yet\n// allowed by fromBase64.\nconst WS_RE = /[\\s]/;\nconst WS_PAD_RE = /[\\s=]/;\n// #region base64\n/** @internal */\nexport const _fromBase64Polyfill = /*#__PURE__*/ createRfc4648Decode(BASE64_CHARSET, 6, false);\n/** @internal */\nexport const _toBase64Polyfill = /*#__PURE__*/ createRfc4648Encode(BASE64_CHARSET, 6, false);\n/** @internal */\nexport const _fromBase64Native = (str) => {\n    if (str.length % 4 === 1 || WS_PAD_RE.test(str)) {\n        throw new SyntaxError(`invalid base64 string`);\n    }\n    return Uint8Array.fromBase64(str, { alphabet: 'base64', lastChunkHandling: 'loose' });\n};\n/** @internal */\nexport const _toBase64Native = (bytes) => {\n    return bytes.toBase64({ alphabet: 'base64', omitPadding: true });\n};\nexport const fromBase64 = !HAS_UINT8_BASE64_SUPPORT ? _fromBase64Polyfill : _fromBase64Native;\nexport const toBase64 = !HAS_UINT8_BASE64_SUPPORT ? _toBase64Polyfill : _toBase64Native;\n// #endregion\n// #region base64pad\n/** @internal */\nexport const _fromBase64PadPolyfill = /*#__PURE__*/ createRfc4648Decode(BASE64_CHARSET, 6, true);\n/** @internal */\nexport const _toBase64PadPolyfill = /*#__PURE__*/ createRfc4648Encode(BASE64_CHARSET, 6, true);\n/** @internal */\nexport const _fromBase64PadNative = (str) => {\n    if (str.length % 4 !== 0 || WS_RE.test(str)) {\n        throw new SyntaxError(`invalid base64 string`);\n    }\n    return Uint8Array.fromBase64(str, { alphabet: 'base64', lastChunkHandling: 'strict' });\n};\n/** @internal */\nexport const _toBase64PadNative = (bytes) => {\n    return bytes.toBase64({ alphabet: 'base64', omitPadding: false });\n};\nexport const fromBase64Pad = !HAS_UINT8_BASE64_SUPPORT ? _fromBase64PadPolyfill : _fromBase64PadNative;\nexport const toBase64Pad = !HAS_UINT8_BASE64_SUPPORT ? _toBase64PadPolyfill : _toBase64PadNative;\n// #endregion\n// #region base64url\n/** @internal */\nexport const _fromBase64UrlPolyfill = /*#__PURE__*/ createRfc4648Decode(BASE64URL_CHARSET, 6, false);\n/** @internal */\nexport const _toBase64UrlPolyfill = /*#__PURE__*/ createRfc4648Encode(BASE64URL_CHARSET, 6, false);\n/** @internal */\nexport const _fromBase64UrlNative = (str) => {\n    if (str.length % 4 === 1 || WS_PAD_RE.test(str)) {\n        throw new SyntaxError(`invalid base64 string`);\n    }\n    return Uint8Array.fromBase64(str, { alphabet: 'base64url', lastChunkHandling: 'loose' });\n};\n/** @internal */\nexport const _toBase64UrlNative = (bytes) => {\n    return bytes.toBase64({ alphabet: 'base64url', omitPadding: true });\n};\nexport const fromBase64Url = !HAS_UINT8_BASE64_SUPPORT ? _fromBase64UrlPolyfill : _fromBase64UrlNative;\nexport const toBase64Url = !HAS_UINT8_BASE64_SUPPORT ? _toBase64UrlPolyfill : _toBase64UrlNative;\n// #endregion\n// #region base64urlpad\n/** @internal */\nexport const _fromBase64UrlPadPolyfill = /*#__PURE__*/ createRfc4648Decode(BASE64URL_CHARSET, 6, true);\n/** @internal */\nexport const _toBase64UrlPadPolyfill = /*#__PURE__*/ createRfc4648Encode(BASE64URL_CHARSET, 6, true);\n/** @internal */\nexport const _fromBase64UrlPadNative = (str) => {\n    if (str.length % 4 !== 0 || WS_RE.test(str)) {\n        throw new SyntaxError(`invalid base64 string`);\n    }\n    return Uint8Array.fromBase64(str, { alphabet: 'base64url', lastChunkHandling: 'strict' });\n};\n/** @internal */\nexport const _toBase64UrlPadNative = (bytes) => {\n    return bytes.toBase64({ alphabet: 'base64url', omitPadding: false });\n};\nexport const fromBase64UrlPad = !HAS_UINT8_BASE64_SUPPORT\n    ? _fromBase64UrlPadPolyfill\n    : _fromBase64UrlPadNative;\nexport const toBase64UrlPad = !HAS_UINT8_BASE64_SUPPORT ? _toBase64UrlPadPolyfill : _toBase64UrlPadNative;\n// #endregion\n//# sourceMappingURL=base64-web.js.map","import { createRfc4648Decode, createRfc4648Encode } from '../utils.js';\nconst BASE32_CHARSET = 'abcdefghijklmnopqrstuvwxyz234567';\nexport const fromBase32 = /*#__PURE__*/ createRfc4648Decode(BASE32_CHARSET, 5, false);\nexport const toBase32 = /*#__PURE__*/ createRfc4648Encode(BASE32_CHARSET, 5, false);\n//# sourceMappingURL=base32.js.map","const MSB = 0x80;\nconst REST = 0x7f;\nconst MSBALL = ~REST;\nconst INT = 2 ** 31;\nconst N1 = 2 ** 7;\nconst N2 = 2 ** 14;\nconst N3 = 2 ** 21;\nconst N4 = 2 ** 28;\nconst N5 = 2 ** 35;\nconst N6 = 2 ** 42;\nconst N7 = 2 ** 49;\nconst N8 = 2 ** 56;\nconst N9 = 2 ** 63;\n/**\n * Encodes a varint\n * @param num Number to encode\n * @param buf Buffer to write on\n * @param offset Starting position on the buffer\n * @returns The amount of bytes written\n */\nexport const encode = (num, buf, offset = 0) => {\n    if (num > Number.MAX_SAFE_INTEGER) {\n        throw new RangeError('could not encode varint');\n    }\n    const start = offset;\n    while (num >= INT) {\n        buf[offset++] = (num & 0xff) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        buf[offset++] = (num & 0xff) | MSB;\n        num >>>= 7;\n    }\n    buf[offset] = num | 0;\n    return offset - start + 1;\n};\n/**\n * Decodes a varint\n * @param buf Buffer to read from\n * @param offset Starting position on the buffer\n * @returns A tuple containing the resulting number, and the amount of bytes read\n */\nexport const decode = (buf, offset = 0) => {\n    // deno-lint-ignore prefer-const\n    let l = buf.length;\n    let res = 0;\n    let shift = 0;\n    let counter = offset;\n    let b;\n    do {\n        if (counter >= l) {\n            throw new RangeError('could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB);\n    return [res, counter - offset];\n};\n/**\n * Returns encoding length\n * @param num The number to encode\n * @returns Amount of bytes needed for encoding\n */\nexport const encodingLength = (num) => {\n    return num < N1\n        ? 1\n        : num < N2\n            ? 2\n            : num < N3\n                ? 3\n                : num < N4\n                    ? 4\n                    : num < N5\n                        ? 5\n                        : num < N6\n                            ? 6\n                            : num < N7\n                                ? 7\n                                : num < N8\n                                    ? 8\n                                    : num < N9\n                                        ? 9\n                                        : 10;\n};\n//# sourceMappingURL=index.js.map","import { fromBase32, toBase32 } from '@atcute/multibase';\nimport { allocUnsafe, toSha256 } from '@atcute/uint8array';\nimport * as varint from '@atcute/varint';\nexport const CID_VERSION = 1;\nexport const HASH_SHA256 = 0x12;\nexport const CODEC_RAW = 0x55;\nexport const CODEC_DCBOR = 0x71;\nexport const create = async (codec, data) => {\n    const digest = await toSha256(data);\n    const digestSize = digest.length;\n    const digestLebSize = varint.encodingLength(digestSize);\n    const bytes = allocUnsafe(3 + digestLebSize + digestSize);\n    bytes[0] = CID_VERSION;\n    bytes[1] = codec;\n    bytes[2] = HASH_SHA256;\n    varint.encode(digestSize, bytes, 3);\n    bytes.set(digest, 3 + digestLebSize);\n    const cid = {\n        version: CID_VERSION,\n        codec: codec,\n        digest: {\n            codec: HASH_SHA256,\n            contents: digest,\n        },\n        bytes: bytes,\n    };\n    return cid;\n};\nexport const decodeFirst = (bytes) => {\n    const length = bytes.length;\n    if (length < 5) {\n        throw new RangeError(`cid too short`);\n    }\n    const version = bytes[0];\n    const codec = bytes[1];\n    const digestCodec = bytes[2];\n    if (version !== CID_VERSION) {\n        throw new RangeError(`incorrect cid version (got v${version})`);\n    }\n    if (codec !== CODEC_DCBOR && codec !== CODEC_RAW) {\n        throw new RangeError(`incorrect cid codec (got 0x${codec.toString(16)})`);\n    }\n    if (digestCodec !== HASH_SHA256) {\n        throw new RangeError(`incorrect cid hash type (got 0x${digestCodec.toString(16)})`);\n    }\n    const [digestSize, digestLebSize] = varint.decode(bytes, 3);\n    const digestOffset = 3 + digestLebSize;\n    if (length - digestOffset < digestSize) {\n        throw new RangeError(`digest too short (expected ${digestSize} bytes; got ${length - digestOffset})`);\n    }\n    const remainder = bytes.subarray(digestOffset + digestSize);\n    const cid = {\n        version: CID_VERSION,\n        codec: codec,\n        digest: {\n            codec: digestCodec,\n            contents: bytes.subarray(digestOffset, digestOffset + digestSize),\n        },\n        bytes: bytes.subarray(0, digestOffset + digestSize),\n    };\n    return [cid, remainder];\n};\nexport const decode = (bytes) => {\n    const [cid, remainder] = decodeFirst(bytes);\n    if (remainder.length !== 0) {\n        throw new RangeError(`cid bytes includes remainder`);\n    }\n    return cid;\n};\nexport const fromString = (input) => {\n    if (input.length < 2 || input[0] !== 'b') {\n        throw new SyntaxError(`not a multibase base32 string`);\n    }\n    const bytes = fromBase32(input.slice(1));\n    return decode(bytes);\n};\nexport const toString = (cid) => {\n    const encoded = toBase32(cid.bytes);\n    return `b${encoded}`;\n};\nexport const fromBinary = (input) => {\n    if (input.length < 2) {\n        throw new RangeError(`cid bytes too short`);\n    }\n    if (input[0] !== 0) {\n        throw new SyntaxError(`incorrect binary cid`);\n    }\n    const bytes = input.subarray(1);\n    return decode(bytes);\n};\nexport const toBinary = (cid) => {\n    const bytes = allocUnsafe(1 + cid.bytes.length);\n    bytes[0] = 0;\n    bytes.set(cid.bytes, 1);\n    return bytes;\n};\n//# sourceMappingURL=codec.js.map","import { toBase32 } from '@atcute/multibase';\nimport { decode, fromString } from './codec.js';\nexport class CidLinkWrapper {\n    bytes;\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    get $link() {\n        const encoded = toBase32(this.bytes);\n        return `b${encoded}`;\n    }\n    toJSON() {\n        return { $link: this.$link };\n    }\n}\nexport const isCidLink = (value) => {\n    const val = value;\n    return (val instanceof CidLinkWrapper ||\n        (val !== null && typeof val === 'object' && typeof val.$link === 'string'));\n};\nexport const toCidLink = (cid) => {\n    return new CidLinkWrapper(cid.bytes);\n};\nexport const fromCidLink = (link) => {\n    if (link instanceof CidLinkWrapper) {\n        return decode(link.bytes);\n    }\n    return fromString(link.$link);\n};\n//# sourceMappingURL=cid-link.js.map","import { fromBase64, toBase64 } from '@atcute/multibase';\nexport class BytesWrapper {\n    buf;\n    constructor(buf) {\n        this.buf = buf;\n    }\n    get $bytes() {\n        return toBase64(this.buf);\n    }\n    toJSON() {\n        return { $bytes: this.$bytes };\n    }\n}\nexport const toBytes = (buf) => {\n    return new BytesWrapper(buf);\n};\nexport const fromBytes = (bytes) => {\n    if (bytes instanceof BytesWrapper) {\n        return bytes.buf;\n    }\n    return fromBase64(bytes.$bytes);\n};\n//# sourceMappingURL=bytes.js.map","import { CidLinkWrapper } from '@atcute/cid';\nimport { decodeUtf8From } from '@atcute/uint8array';\nimport { toBytes } from './bytes.js';\nconst readArgument = (state, info) => {\n    if (info < 24) {\n        return info;\n    }\n    switch (info) {\n        case 24: {\n            return readUint8(state);\n        }\n        case 25: {\n            return readUint16(state);\n        }\n        case 26: {\n            return readUint32(state);\n        }\n        case 27: {\n            return readUint53(state);\n        }\n    }\n    throw new Error(`invalid argument encoding; got ${info}`);\n};\nconst readFloat64 = (state) => {\n    const view = (state.v ??= new DataView(state.b.buffer, state.b.byteOffset, state.b.byteLength));\n    const value = view.getFloat64(state.p);\n    state.p += 8;\n    return value;\n};\nconst readUint8 = (state) => {\n    return state.b[state.p++];\n};\nconst readUint16 = (state) => {\n    let pos = state.p;\n    const buf = state.b;\n    const value = (buf[pos++] << 8) | buf[pos++];\n    state.p = pos;\n    return value;\n};\nconst readUint32 = (state) => {\n    let pos = state.p;\n    const buf = state.b;\n    const value = ((buf[pos++] << 24) | (buf[pos++] << 16) | (buf[pos++] << 8) | buf[pos++]) >>> 0;\n    state.p = pos;\n    return value;\n};\nconst readUint53 = (state) => {\n    let pos = state.p;\n    const buf = state.b;\n    const hi = ((buf[pos++] << 24) | (buf[pos++] << 16) | (buf[pos++] << 8) | buf[pos++]) >>> 0;\n    if (hi > 0x1fffff) {\n        throw new RangeError(`can't decode integers beyond safe integer range`);\n    }\n    const lo = ((buf[pos++] << 24) | (buf[pos++] << 16) | (buf[pos++] << 8) | buf[pos++]) >>> 0;\n    const value = hi * 2 ** 32 + lo;\n    state.p = pos;\n    return value;\n};\nconst readString = (state, length) => {\n    const string = decodeUtf8From(state.b, state.p, length);\n    state.p += length;\n    return string;\n};\nconst readBytes = (state, length) => {\n    const slice = state.b.subarray(state.p, (state.p += length));\n    return toBytes(slice);\n};\nconst readTypeInfo = (state) => {\n    const prelude = readUint8(state);\n    return [prelude >> 5, prelude & 0x1f];\n};\nconst readCid = (state, length) => {\n    // CID bytes are prefixed with 0x00 for historical reasons, apparently.\n    const slice = state.b.subarray(state.p + 1, (state.p += length));\n    return new CidLinkWrapper(slice);\n};\nvar ContainerType;\n(function (ContainerType) {\n    ContainerType[ContainerType[\"MAP\"] = 0] = \"MAP\";\n    ContainerType[ContainerType[\"ARRAY\"] = 1] = \"ARRAY\";\n})(ContainerType || (ContainerType = {}));\nexport const decodeFirst = (buf) => {\n    const len = buf.length;\n    const state = {\n        b: buf,\n        v: null,\n        p: 0,\n    };\n    let stack = null;\n    let result;\n    jump: while (state.p < len) {\n        const prelude = readUint8(state);\n        const type = prelude >> 5;\n        const info = prelude & 0x1f;\n        const arg = type < 7 ? readArgument(state, info) : 0;\n        let value;\n        switch (type) {\n            case 0: {\n                value = arg;\n                break;\n            }\n            case 1: {\n                value = -1 - arg;\n                break;\n            }\n            case 2: {\n                value = readBytes(state, arg);\n                break;\n            }\n            case 3: {\n                value = readString(state, arg);\n                break;\n            }\n            case 4: {\n                const arr = new Array(arg);\n                value = arr;\n                if (arg > 0) {\n                    stack = { t: ContainerType.ARRAY, c: arr, k: null, r: arg, n: stack };\n                    continue jump;\n                }\n                break;\n            }\n            case 5: {\n                const obj = {};\n                value = obj;\n                if (arg > 0) {\n                    // `arg * 2` because we're reading both keys and values\n                    stack = { t: ContainerType.MAP, c: obj, k: null, r: arg * 2, n: stack };\n                    continue jump;\n                }\n                break;\n            }\n            case 6: {\n                switch (arg) {\n                    case 42: {\n                        const [type, info] = readTypeInfo(state);\n                        if (type !== 2) {\n                            throw new TypeError(`expected cid-link to be type 2 (bytes); got type ${type}`);\n                        }\n                        const len = readArgument(state, info);\n                        value = readCid(state, len);\n                        break;\n                    }\n                    default: {\n                        throw new TypeError(`unsupported tag; got ${arg}`);\n                    }\n                }\n                break;\n            }\n            case 7: {\n                switch (info) {\n                    case 20:\n                    case 21: {\n                        value = info === 21;\n                        break;\n                    }\n                    case 22: {\n                        value = null;\n                        break;\n                    }\n                    case 27: {\n                        value = readFloat64(state);\n                        break;\n                    }\n                    default: {\n                        throw new Error(`invalid simple value; got ${info}`);\n                    }\n                }\n                break;\n            }\n            default: {\n                throw new TypeError(`invalid type; got ${type}`);\n            }\n        }\n        while (stack !== null) {\n            const node = stack;\n            switch (node.t) {\n                case ContainerType.ARRAY: {\n                    const index = node.c.length - node.r;\n                    node.c[index] = value;\n                    break;\n                }\n                case ContainerType.MAP: {\n                    if (node.k === null) {\n                        if (typeof value !== 'string') {\n                            throw new TypeError(`expected map to only have string keys; got ${type}`);\n                        }\n                        node.k = value;\n                    }\n                    else {\n                        if (node.k === '__proto__') {\n                            // Guard against prototype pollution. CWE-1321\n                            Object.defineProperty(node.c, node.k, { enumerable: true, configurable: true, writable: true });\n                        }\n                        node.c[node.k] = value;\n                        node.k = null;\n                    }\n                    break;\n                }\n            }\n            if (--node.r !== 0) {\n                // We still have more values to decode, continue\n                continue jump;\n            }\n            // Unwrap the stack\n            value = node.c;\n            stack = node.n;\n        }\n        result = value;\n        break;\n    }\n    return [result, buf.subarray(state.p)];\n};\nexport const decode = (buf) => {\n    const [value, remainder] = decodeFirst(buf);\n    if (remainder.length !== 0) {\n        throw new Error(`decoded value contains remainder`);\n    }\n    return value;\n};\n//# sourceMappingURL=decode.js.map","export const createUint8Reader = (buf) => {\n    let pos = 0;\n    return {\n        get pos() {\n            return pos;\n        },\n        seek(size) {\n            if (size > buf.length - pos) {\n                throw new RangeError('unexpected end of data');\n            }\n            pos += size;\n        },\n        upto(size) {\n            return buf.subarray(pos, pos + Math.min(size, buf.length - pos));\n        },\n        exactly(size, seek) {\n            if (size > buf.length - pos) {\n                throw new RangeError('unexpected end of data');\n            }\n            const slice = buf.subarray(pos, pos + size);\n            if (seek) {\n                pos += size;\n            }\n            return slice;\n        },\n    };\n};\n//# sourceMappingURL=sync-byte-reader.js.map","import * as CBOR from '@atcute/cbor';\nimport * as CID from '@atcute/cid';\nexport const isCarV1Header = (value) => {\n    if (value === null || typeof value !== 'object') {\n        return false;\n    }\n    const { version, roots } = value;\n    return version === 1 && Array.isArray(roots) && roots.every((root) => root instanceof CBOR.CidLinkWrapper);\n};\n//# sourceMappingURL=car.js.map","import * as CBOR from '@atcute/cbor';\nimport * as CID from '@atcute/cid';\nimport * as varint from '@atcute/varint';\nimport { isCarV1Header } from './car.js';\nconst readVarint = (reader, size) => {\n    const buf = reader.upto(size);\n    if (buf.length === 0) {\n        throw new RangeError(`unexpected end of data`);\n    }\n    const [int, read] = varint.decode(buf);\n    reader.seek(read);\n    return int;\n};\nconst readHeader = (reader) => {\n    const length = readVarint(reader, 8);\n    if (length === 0) {\n        throw new RangeError(`invalid car header; length=0`);\n    }\n    const rawHeader = reader.exactly(length, true);\n    const header = CBOR.decode(rawHeader);\n    if (!isCarV1Header(header)) {\n        throw new TypeError(`expected a car v1 archive`);\n    }\n    return header;\n};\nconst readCid = (reader) => {\n    const head = reader.upto(3 + 4);\n    const version = head[0];\n    const codec = head[1];\n    const digestCodec = head[2];\n    if (version !== CID.CID_VERSION) {\n        throw new RangeError(`incorrect cid version (got v${version})`);\n    }\n    if (codec !== CID.CODEC_DCBOR && codec !== CID.CODEC_RAW) {\n        throw new RangeError(`incorrect cid codec (got 0x${codec.toString(16)})`);\n    }\n    if (digestCodec !== CID.HASH_SHA256) {\n        throw new RangeError(`incorrect cid hash type (got 0x${digestCodec.toString(16)})`);\n    }\n    const [digestSize, digestLebSize] = varint.decode(head, 3);\n    const bytes = reader.exactly(3 + digestLebSize + digestSize, true);\n    const digest = bytes.subarray(3 + digestLebSize);\n    const cid = {\n        version: version,\n        codec: codec,\n        digest: {\n            codec: digestCodec,\n            contents: digest,\n        },\n        bytes: bytes,\n    };\n    return cid;\n};\nconst readBlockHeader = (reader) => {\n    const start = reader.pos;\n    let size = readVarint(reader, 8);\n    if (size === 0) {\n        throw new Error(`invalid car section; length=0`);\n    }\n    size += reader.pos - start;\n    const cid = readCid(reader);\n    const blockSize = size - (reader.pos - start);\n    return { cid, blockSize };\n};\nexport const createCarReader = (reader) => {\n    const { roots } = readHeader(reader);\n    return {\n        roots,\n        *iterate() {\n            while (reader.upto(8).length > 0) {\n                const { cid, blockSize } = readBlockHeader(reader);\n                const bytes = reader.exactly(blockSize, true);\n                yield { cid, bytes };\n            }\n        },\n    };\n};\n//# sourceMappingURL=sync-car-reader.js.map","import { createUint8Reader } from './utilities/sync-byte-reader.js';\nimport { createCarReader } from './utilities/sync-car-reader.js';\nexport const readCar = (buffer) => {\n    const reader = createUint8Reader(buffer);\n    return createCarReader(reader);\n};\n//# sourceMappingURL=reader.js.map","// @ts-check\n/// <reference types='@atproto/api' />\n\nimport { readCar } from '@atcute/car';\nimport { decode, decodeFirst, fromBytes, toCidLink } from '@atcute/cbor';\n\nimport { version } from './package.json';\nexport { version };\n\nconst emptyUint8Array = new Uint8Array();\n\n/**\n * @typedef {{\n *  'app.bsky.feed.like': import('@atproto/api').AppBskyFeedLike.Record,\n *  'app.bsky.feed.post': import('@atproto/api').AppBskyFeedPost.Record,\n *  'app.bsky.feed.repost': import('@atproto/api').AppBskyFeedRepost.Record,\n *  'app.bsky.feed.threadgate': import('@atproto/api').AppBskyFeedThreadgate.Record,\n *  'app.bsky.graph.follow': import('@atproto/api').AppBskyGraphFollow.Record,\n *  'app.bsky.graph.block': import('@atproto/api').AppBskyGraphBlock.Record,\n *  'app.bsky.graph.list': import('@atproto/api').AppBskyGraphList.Record,\n *  'app.bsky.graph.listitem': import('@atproto/api').AppBskyGraphListitem.Record,\n *  'app.bsky.graph.listblock': import('@atproto/api').AppBskyGraphListblock.Record,\n *  'app.bsky.actor.profile': import('@atproto/api').AppBskyActorProfile.Record\n *  'app.bsky.feed.generator': import('@atproto/api').AppBskyFeedGenerator.Record\n *  'app.bsky.feed.postgate': import('@atproto/api').AppBskyFeedPostgate.Record\n *  'chat.bsky.actor.declaration': import('@atproto/api').ChatBskyActorDeclaration.Record,\n *  'app.bsky.graph.starterpack': import('@atproto/api').AppBskyGraphStarterpack.Record\n * }} RepositoryRecordTypes$\n */\n\n/**\n * @template {keyof RepositoryRecordTypes$} $Type\n * @typedef {RepositoryRecordTypes$[$Type] & {\n *  repo: string,\n *  uri: string,\n *  cid: string,\n *  action: 'create' | 'update',\n *  path: string,\n *  $type: $Type,\n *  since: string,\n *  time: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * }} FirehoseRepositoryRecord\n */\n\n/**\n * @typedef {{\n *  repo: string,\n *  uri: string,\n *  action: 'delete',\n *  path: string,\n *  $type: keyof RepositoryRecordTypes$,\n *  since: string,\n *  time: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * }} FirehoseDeleteRecord\n */\n\n\n/**\n * @typedef {{\n *  $type: '#identity',\n *  repo: string,\n *  action?: never,\n *  handle: string,\n *  time: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * }} FirehoseIdentityRecord\n */\n\n/**\n * @typedef {{\n *  $type: '#identity',\n *  repo: string,\n *  action?: never,\n *  active: boolean,\n *  time: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * }} FirehoseAccountRecord\n */\n\n/**\n * @typedef {{\n *  $type: 'error',\n *  action?: never,\n *  message: string,\n *  receiveTimestamp: number,\n *  parseTime: number\n * } & Record<string, unknown>} FirehoseErrorRecord\n */\n\n/**\n * @typedef {FirehoseRepositoryRecord<'app.bsky.feed.like'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.post'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.repost'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.threadgate'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.follow'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.block'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.list'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.listitem'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.listblock'> |\n * FirehoseRepositoryRecord<'app.bsky.actor.profile'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.generator'> |\n * FirehoseRepositoryRecord<'app.bsky.feed.postgate'> |\n * FirehoseRepositoryRecord<'chat.bsky.actor.declaration'> |\n * FirehoseRepositoryRecord<'app.bsky.graph.starterpack'> |\n * FirehoseDeleteRecord |\n * FirehoseIdentityRecord |\n * FirehoseAccountRecord |\n * FirehoseErrorRecord\n * } FirehoseRecord\n */\n\nexport const known$Types = /** @type {const} */([\n  'app.bsky.feed.like', 'app.bsky.feed.post', 'app.bsky.feed.repost', 'app.bsky.feed.threadgate',\n  'app.bsky.graph.follow', 'app.bsky.graph.block', 'app.bsky.graph.list', 'app.bsky.graph.listitem', 'app.bsky.graph.listblock',\n  'app.bsky.actor.profile',\n  'app.bsky.feed.generator',\n  'app.bsky.feed.postgate',\n  'chat.bsky.actor.declaration',\n  'app.bsky.graph.starterpack'\n]);\n\nfirehose.knownTypes = known$Types;\n\nfunction requireWebsocket() {\n  const globalObj = typeof global !== 'undefined' && global || typeof globalThis !== 'undefined' && globalThis;\n  const requireFn = globalObj?.['require'];\n  if (typeof requireFn === 'function') return /** @type {typeof WebSocket} */(requireFn('ws'));\n  throw new Error('WebSocket not available');\n}\n\nfirehose.each = each;\nfirehose.version = version;\n\n/**\n * @param {string} [address]\n * @returns {AsyncGenerator<FirehoseRecord[], void, void>}\n */\nexport async function* firehose(address) {\n  const WebSocketImpl = typeof WebSocket === 'function' ? WebSocket :\n    requireWebsocket();\n\n  const wsAddress = address || 'wss://bsky.network/xrpc/com.atproto.sync.subscribeRepos';\n\n  const ws = new WebSocketImpl(wsAddress);\n  ws.binaryType = 'arraybuffer';\n  ws.addEventListener('message', handleMessage);\n  ws.addEventListener('error', handleError);\n  ws.addEventListener('close', handleClose)\n\n  let buf = createAwaitPromise();\n  let closed = false;\n\n  try {\n\n    while (true) {\n      await buf.promise;\n      if (buf.block?.length) {\n        const block = buf.block;\n        buf = createAwaitPromise();\n        if (closed) {\n          block['messages'] = block; // backwards compatibility trick\n          if (block.length) yield block;\n          break;\n        }\n        yield block;\n      } else {\n        buf = createAwaitPromise();\n      }\n    }\n  } finally {\n    if (!closed) {\n      try { ws.close(); }\n      catch (error) { }\n    }\n  }\n\n  function handleClose() {\n    closed = true;\n    buf.resolve();\n  }\n\n  function handleMessage(event) {\n    const receiveTimestamp = Date.now();\n\n    if (typeof event.data?.byteLength === 'number') {\n      parseMessageBufAndResolve(receiveTimestamp, event.data);\n    } else if (typeof event.data?.arrayBuffer === 'function') {\n      event.data.arrayBuffer().then(arrayBuffer => parseMessageBufAndResolve(receiveTimestamp, arrayBuffer))\n    } else {\n      buf.block.push({\n        $type: 'error',\n        message: 'WebSocket message type not supported.',\n        data: event.data,\n        receiveTimestamp,\n        parseTime: 0\n      });\n      buf.resolve();\n    }\n  }\n\n  /**\n   * @param {number} receiveTimestamp\n   * @param {ArrayBuffer} arrayBuf\n   */\n  function parseMessageBufAndResolve(receiveTimestamp, arrayBuf) {\n    parseMessageBuf(receiveTimestamp, new Uint8Array(arrayBuf));\n    buf.resolve();\n  }\n\n  /**\n   * @param {number} receiveTimestamp\n   * @param {Uint8Array} messageBuf\n   */\n  function parseMessageBuf(receiveTimestamp, messageBuf) {\n    const parseStart = performance.now();\n    try {\n      parseMessageBufWorker(receiveTimestamp, parseStart, messageBuf);\n      buf.resolve();\n    } catch (parseError) {\n      buf.block.push({\n        $type: 'error',\n        message: parseError.message,\n        receiveTimestamp,\n        parseTime: performance.now() - parseStart\n      });\n    }\n\n    buf.resolve();\n  }\n\n  /**\n * @param {number} receiveTimestamp\n * @param {number} parseStart\n * @param {Uint8Array} messageBuf\n */\n  function parseMessageBufWorker(receiveTimestamp, parseStart, messageBuf) {\n    const [header, remainder] = decodeFirst(messageBuf);\n    const [body, remainder2] = decodeFirst(remainder);\n    if (remainder2.length > 0) {\n      return buf.block.push({\n        $type: 'error',\n        message: 'Excess bytes in message.',\n        receiveTimestamp,\n        parseTime: performance.now() - parseStart\n      });\n    }\n\n    const { t, op } = header;\n\n    if (op === -1) {\n      return buf.block.push({\n        $type: 'error',\n        message: 'Error header#' + body.error + ': ' + body.message,\n        receiveTimestamp,\n        parseTime: performance.now() - parseStart\n      });\n    }\n\n    if (t === '#commit') {\n      const commit = body;\n\n      // A commit can contain no changes\n      if (!('blocks' in commit) || !(commit.blocks.$bytes.length)) {\n        return buf.block.push({\n          $type: 'com.atproto.sync.subscribeRepos#commit',\n          ...commit,\n          blocks: emptyUint8Array,\n          ops: [],\n          receiveTimestamp,\n          parseTime: performance.now() - parseStart\n        });\n      }\n\n      const blocks = fromBytes(commit.blocks);\n      const car = readCarToMap(blocks);\n      for (let opIndex = 0; opIndex < commit.ops.length; opIndex++) {\n        const op = commit.ops[opIndex];\n        const action = op.action;\n\n        const now = performance.now();\n        const record = op.cid ? car.get(op.cid.$link) : undefined;\n\n        if (action === 'create' || action === 'update') {\n          if (!op.cid) {\n            buf.block.push({\n              $type: 'error',\n              message: 'Missing commit.ops[' + (opIndex - 1) + '].cid.',\n              receiveTimestamp,\n              parseTime: now - parseStart,\n              commit\n            });\n            parseStart = now;\n            continue;\n          }\n\n          if (!record) {\n            buf.block.push({\n              $type: 'error',\n              message: 'Unresolved commit.ops[' + (opIndex - 1) + '].cid ' + op.cid,\n              receiveTimestamp,\n              parseTime: now - parseStart,\n              commit\n            });\n            parseStart = now;\n            continue;\n          }\n\n          record.action = action;\n          record.uri = 'at://' + commit.repo + '/' + op.path;\n          record.path = op.path;\n          record.cid = op.cid;\n          record.receiveTimestamp = receiveTimestamp;\n          record.parseTime = now - parseStart;\n\n          buf.block.push(record);\n          continue;\n        } else if (action === 'delete') {\n          buf.block.push({\n            action,\n            path: op.path,\n            receiveTimestamp,\n            parseTime: now - parseStart\n          });\n          parseStart = now;\n        } else {\n          buf.block.push({\n            $type: 'error',\n            message: 'Unknown action ' + op.action,\n            ...record,\n            receiveTimestamp,\n            parseTime: now - parseStart\n          });\n          parseStart = now;\n          continue;\n        }\n      }\n      return;\n    }\n\n    return buf.block.push({\n      $type: t,\n      ...body,\n      receiveTimestamp,\n      parseTime: performance.now() - parseStart\n    });\n  }\n\n  function handleError(error) {\n    console.error(error);\n    const errorText =\n      error.message || 'WebSocket error ' + error;\n    buf.reject(new Error(errorText));\n  }\n\n}\n\n/**\n * @param {string} [address]\n * @returns {AsyncGenerator<FirehoseRecord, void, void>}\n */\nasync function* each(address) {\n  for await (const block of firehose(address)) {\n    yield* block;\n  }\n}\n\n/**\n * @returns {{\n *  block: FirehoseRecord[],\n *  resolve: () => void,\n *  reject: (reason?: any) => void,\n *  promise: Promise<void>\n * }} */\nfunction createAwaitPromise() {\n  const result = {\n    /** @type {FirehoseRecord[]} */\n    block: []\n  };\n  result.promise = new Promise((resolve, reject) => {\n    result.resolve = resolve;\n    result.reject = reject;\n  });\n  return /** @type {*} */(result);\n}\n\n/** @param {Uint8Array} buffer */\nfunction readCarToMap(buffer) {\n  const records = new Map();\n  for (const { cid, bytes } of readCar(buffer).iterate()) {\n    records.set(toCidLink(cid).$link, decode(bytes));\n  }\n  return records;\n}\n","// @ts-check\n\nimport { firehose as bski_firehose } from 'bski';\n\n/** @param {string} [address] */\nexport async function* firehose(address) {\n  for await (const record of bski_firehose(address)) {\n    record['messages'] = record;\n    yield record;\n  }\n}\n"],"names":["TextEncoder","textDecoder","TextDecoder","alloc","size","Uint8Array","allocUnsafe","decodeUtf8From","from","offset","length","buffer","undefined","subarray","result","decode","createRfc4648Encode","alphabet","bitsPerChar","pad","bytes","mask","str","bits","i","createRfc4648Decode","codes","end","written","value","SyntaxError","HAS_UINT8_BASE64_SUPPORT","BASE64_CHARSET","WS_PAD_RE","_fromBase64Polyfill","_toBase64Polyfill","_fromBase64Native","test","fromBase64","lastChunkHandling","_toBase64Native","toBase64","omitPadding","BASE32_CHARSET","toBase32","MSB","REST","buf","l","res","shift","counter","b","RangeError","Math","pow","CID_VERSION","HASH_SHA256","CODEC_RAW","CODEC_DCBOR","CidLinkWrapper","constructor","$link","encoded","toJSON","toCidLink","cid","BytesWrapper","$bytes","toBytes","fromBytes","readArgument","state","info","readUint8","readUint16","readUint32","readUint53","Error","readFloat64","view","v","DataView","byteOffset","byteLength","getFloat64","p","pos","hi","lo","readString","string","readBytes","slice","readTypeInfo","prelude","readCid","ContainerType","decodeFirst","len","stack","jump","type","arg","arr","Array","t","ARRAY","c","k","r","n","obj","MAP","TypeError","node","index","Object","defineProperty","enumerable","configurable","writable","remainder","createUint8Reader","seek","upto","min","exactly","isCarV1Header","version","roots","isArray","every","root","CBOR","readVarint","reader","int","read","varint","readHeader","rawHeader","header","head","codec","digestCodec","CID","toString","digestSize","digestLebSize","digest","contents","readBlockHeader","start","blockSize","createCarReader","iterate","readCar","emptyUint8Array","known$Types","firehose","knownTypes","requireWebsocket","globalObj","global","globalThis","requireFn","each","address","WebSocketImpl","WebSocket","wsAddress","ws","binaryType","addEventListener","handleMessage","handleError","handleClose","createAwaitPromise","closed","promise","block","close","error","resolve","event","receiveTimestamp","Date","now","data","parseMessageBufAndResolve","arrayBuffer","then","push","$type","message","parseTime","arrayBuf","parseMessageBuf","messageBuf","parseStart","performance","parseMessageBufWorker","parseError","body","remainder2","op","commit","blocks","ops","car","readCarToMap","opIndex","action","record","get","uri","repo","path","console","errorText","reject","Promise","records","Map","set","bski_firehose"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}